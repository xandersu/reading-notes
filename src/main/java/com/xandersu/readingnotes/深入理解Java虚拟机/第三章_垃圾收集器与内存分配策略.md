# 第三章 垃圾收集器与内存分配策略

## 3.2 对象已死吗

垃圾收集器进行回收前，需要判断哪些对象还活着，哪些对象已经死去（即不可能再被任何途径使用的对象）

### 3.2.1 引用计数法

主流的Java虚拟机里没有选用引用计数器算法来实现管理内存，主要原因：很难解决对象之间的**循环引用**的问题。

### 3.2.2 可达性分析算法

主流商用程序语言（Java、C#、Lisp）通过可达性分析（Reachability Analysis）来判定对象是否活着。基本思路，通过一系列的称为“GC Roots” 的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，证明对象时不可用的。

Java语言中，可作为GC Roots的对象包括：

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法中JNI（Native方法）引用的对象

### 3.2.3 再谈引用

JDK1.2之前，Java引用定义：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称为这块内存代表着一个引用。

JDK1.2之后，对引用概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用 （Phantom Reference）。

- 强引用指程序代码中普遍存在的，new，只要强引用还在垃圾回收器永远不会回收掉引用的对象。
- 软引用用来描述一些还有用但并非必需的对象，软引用的对象，在系统将要放生内存溢出异常前，将这些对象列进回收范围之中进行第二次回收，如果本次回收仍未有足够的内存，才会抛出内存溢出异常。JDK1.2之后，SoftReference类实现软引用。
- 弱引用用来描述非必需对象，强度比弱引用弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生之前。进行垃圾回收时，无论当时内存是否足够，都会回收掉弱引用关联的对象。WeakReference类实现。
- 虚引用，一个对象是否有虚引用的存在，不影响其生存的时间，也无法通过一个虚引用来取得一个对象实例。设置虚引用唯一目的，能在这个对象被收集器收集之前收到一个人系统通知。PhantomReference

### 3.2.4 生存还是死亡

真正宣告一个对象死亡，至少要经历两次标记过程：

对象在进行可达性分析后发现没有与GC Roots相连接的引用链，他将被第一次标记并进行一次筛选，筛选条件是此时该对象是否有必要执行finalize()方法。当对象没有覆盖finalize方法、或者方法被JVM调用过，虚拟机都认为没有必要执行。

如果对象被判定有必要执行finalize方法，这个对象会放置在一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动创建的低优先级的Finalizer线程去执行它。虚拟机会触发finalize方法，但不保证会等待方法执行结束。finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC会对F-Queue中的对象进行第二次小规模标记，如果要在finalize方法拯救自己——重新与引用链上任何一个对象建立关联，那么它在第二次标记时将被移出“即将回收”集合，如果仍然没有逃脱，则被回收。

1. 对象可以在被GC时自我拯救
2. 这种自救机会只有一次，因为一个对象的finalize方法最多会被系统自动调用一次

特别说明，finalize运行代价高昂、不确定性大、无法保证各个对象的调用顺序，建议忘掉这个方法。

### 3.2.5 回收方法区

jvm规范里不要求在方法区实现垃圾收集，而且方法区垃圾收集性价比低。

永久代的垃圾收集主要两部门：废弃常量和无用的类。

常量与堆中对象相似。

判断无用的类条件苛刻：

- 该类所有的实例都已经被回收，Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反访问该类的方法。

满足上述3点，可以被回收，但不是必然被回收。

HotSpot 虚拟机提供 -Xnoclassgc参数进行控制，可以使用-verbose:class 和 -XX:+TraceClassLoading , -XX:+TraceClassUnloading查看类加载和卸载信息。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OGSi这类频繁自定义ClassLoader的场景度需要虚拟机有类卸载的功能，以保证永久代不会溢出。

## 3.3 垃圾收集算法

### 3.3.1 标记-清除算法

标记-清除（Mark-Aweep）算法，最基础，算法分为“标记”和“清除”两个阶段：首先标记除所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

两个不足：

1. 效率，标记和清除两个过程效率都不高；
2. 空间问题，标记清除后会产生大量不连续的内存碎片，可能会导致需要分配较大的对象时，无法找到足够的连续内存二不得不提前触发另一次垃圾收集动作。

### 3.3.2 复制算法

复制（Copying）算法：将可用内存划按容量分成大小相等的两块，每次只使用其中的一块。当其中一块内存用完后，将还存活的对象复制到另外一块，再把已使用过的内存空间一次清理掉。

不足：内存缩小为原来的一半。

将内存分为较大的Eden空间和两块较小的survivor空间，每次使用Eden和其中一块survivor，当回收时，将eden区和survivor区中还活着的对象一次性的复制到另外一块survivor区，最后清理掉Eden区和刚用过的survivor区。HotSpot默认Eden和survivor大小比例：8：1。

当survivor空间不够时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）。

### 3.3.3 标记-整理算法

复制算法在对象存活率较高时需要额外进行较多的复制操作，效率会变低。老年代没有分配担保，一般不直接选用复制算法。

标记-整理（Mark-Compact）算法，，标记后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一段移动，直接清理掉端边界以外的内存。

### 3.3.4 分代收集算法

分代收集（Generational Collection）算法，根据对象存活周期的不同把内存分为几块，一般把Java堆分为新生代和老年代，新生代，对存活的少选用复制算法，老年代对象存活率高、没有额外的分配担保，就使用“标记清理”和标记整理。

## 3.4 HotSpot的算实现

可达性分析

必须在一个能确保一致性的快照中进行。导致GC必须停顿所有Java执行线程（Stop the world）。

OopMap

### 3.4.2 安全点

Safepoint，程序执行时并非所有地方都停顿下来开始GC，只有到达安全点时才暂停。

如何在GC发生时让所有线程（不包括jni线程）都跑到最近的安全点再停下来，两种方案：抢先式中断（Preemptive Suspension）和主动式中断(Voluntary Suspension)

1. 抢先式中断:GC发生时，所有线程都中断，如果线程中断不在安全点上，恢复线程，跑到安全点上。几乎没有虚拟机使用。
2. 主动式中断：GC需要中断线程时1，不直对线程进行操作，设置标志，各个线程执行时主动轮询标志，发现中断标志为真就自己中断挂起。轮询标志的地方与安全点重合，另外创建对象需要分配内存的时候。

### 3.4.3 安全区域

程序没有分配CPU时间，处于Sleep和Blocked状态，线程无法响应JVM的中断请求，到安全点中断挂起，需要安全区域（Safe Region）解决。

安全区域指一段代码判断中，引用关系不在发生变化，在这个区域任意地方开始GC都是安全的。

线程执行到Safe Region时，表示自己进入了Safe Region，当线程要离开Safe Region时，要检查系统是否完成了根节点枚举，如果完成了就继续执行，否则要等到收到离开信号才行。

## 3.5 垃圾收集器

### 3.5.1 Serial收集器

单线程的收集器，只会使用一个CPU或者一条收集线程去完成垃圾收集的工作，工作时必须暂停所有工作线程，直到收集结束。

client模式下新生代很好的选择。

### 3.5.2 ParNew收集器

Serial收集器多线程版本。

server模式新生代首选的收集器。只有他能与CMS收集器配合工作。

### 3.5.3 Parallel Scavenge 收集器

新生代收集器，复制算法，

CMS关注点是缩短GC时用户等待时间。

 Parallel Scavenge关注点是达到一个可控制的吞吐量（Throughput）。吞吐量=运行用户代码时间/（运行用户代码时间+GC时间）。

吞吐量优先收集器

-XX:+UseAdaptiveSizePolicy开关参数，打开后。不需要手动指定新生代大小、Eden和Survivor区的比例、晋升老年代对象的大小等细节参数，虚拟机动态调整以提供最合适的停顿时间或者最大的吞吐量，称为GC自适应的调节策略（GC Ergonomics）。

### 3.5.4 Serial old 收集器

Serial收集器的老年代版本，主要给client老年代用，server模式下，两个作用：1、JDK 1.5之后搭配Parallel Scavenge 使用。2、CMS收集器的后背预案。

### 3.5.5 Parallel Old 收集器

 Parallel Scavenge 收集器老年代版本，多线程和标记整理法，JDK1.6之后提供。

Parallel Scavenge只能和Serial old 使用，老年代GC在服务端性能拖累。
