# 第三章 垃圾收集器与内存分配策略

## 3.2 对象已死吗

垃圾收集器进行回收前，需要判断哪些对象还活着，哪些对象已经死去（即不可能再被任何途径使用的对象）

### 3.2.1 引用计数法

主流的Java虚拟机里没有选用引用计数器算法来实现管理内存，主要原因：很难解决对象之间的**循环引用**的问题。

### 3.2.2 可达性分析算法

主流商用程序语言（Java、C#、Lisp）通过可达性分析（Reachability Analysis）来判定对象是否活着。基本思路，通过一系列的称为“GC Roots” 的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，证明对象时不可用的。

Java语言中，可作为GC Roots的对象包括：

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法中JNI（Native方法）引用的对象

###  3.2.3 再谈引用

JDK1.2之前，Java引用定义：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称为这块内存代表着一个引用。

JDK1.2之后，对引用概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用 （Phantom Reference）。

- 强引用指程序代码中普遍存在的，new，只要强引用还在垃圾回收器永远不会回收掉引用的对象。
- 软引用用来描述一些还有用但并非必需的对象，软引用的对象，在系统将要放生内存溢出异常前，将这些对象列进回收范围之中进行第二次回收，如果本次回收仍未有足够的内存，才会抛出内存溢出异常。JDK1.2之后，SoftReference类实现软引用。
- 弱引用用来描述非必需对象，强度比弱引用弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生之前。进行垃圾回收时，无论当时内存是否足够，都会回收掉弱引用关联的对象。WeakReference类实现。
- 虚引用，一个对象是否有虚引用的存在，不影响其生存的时间，也无法通过一个虚引用来取得一个对象实例。设置虚引用唯一目的，能在这个对象被收集器收集之前收到一个人系统通知。PhantomReference

### 3.2.4 生存还是死亡

真正宣告一个对象死亡，至少要经历两次标记过程：

对象在进行可达性分析后发现没有与GC Roots相连接的引用链，他将被第一次标记并进行一次筛选，筛选条件是此时该对象是否有必要执行finalize()方法。当对象没有覆盖finalize方法、或者方法被JVM调用过，虚拟机都认为没有必要执行。

如果对象被判定有必要执行finalize方法，这个对象会放置在一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动创建的低优先级的Finalizer线程去执行它。虚拟机会触发finalize方法，但不保证会等待方法执行结束。finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC会对F-Queue中的对象进行第二次小规模标记，如果要在finalize方法拯救自己——重新与引用链上任何一个对象建立关联，那么它在第二次标记时将被移出“即将回收”集合，如果仍然没有逃脱，则被回收。

1. 对象可以在被GC时自我拯救
2. 这种自救机会只有一次，因为一个对象的finalize方法最多会被系统自动调用一次

特别说明，finalize运行代价高昂、不确定性大、无法保证各个对象的调用顺序，建议忘掉这个方法。

### 3.2.5 回收方法区

jvm规范里不要求在方法区实现垃圾收集，而且方法区垃圾收集性价比低。

永久代的垃圾收集主要两部门：废弃常量和无用的类。

常量与堆中对象相似。

判断无用的类条件苛刻：

- 该类所有的实例都已经被回收，Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反访问该类的方法。

满足上述3点，可以被回收，但不是必然被回收。

HotSpot 虚拟机提供 -Xnoclassgc参数进行控制，可以使用-verbose:class 和 -XX:+TraceClassLoading , -XX:+TraceClassUnloading查看类加载和卸载信息。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OGSi这类频繁自定义ClassLoader的场景度需要虚拟机有类卸载的功能，以保证永久代不会溢出。

