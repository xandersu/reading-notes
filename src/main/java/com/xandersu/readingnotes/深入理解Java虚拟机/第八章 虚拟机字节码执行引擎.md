# 第八章 虚拟机字节码执行引擎

## 8.1 概述

执行引擎是JVM最核心的组成部分之一。

物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的。

虚拟机的执行引擎由自己实现，可以自行定制指令集和执行引擎的结构体系，能够执行不被硬件直接支持的指令集格式。 

JVM规范中制定了虚拟机字节码执行引擎的概念模型，称为各个虚拟机执行引擎的统一外观(Facade

)。在不同的虚拟机实现里，执行引擎在执行Java代码时可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，也可能包含几个不同级别的编译器执行引擎。但外观上看，所有JVM的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

## 8.2 运行时栈帧结构

栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

每一个栈帧都包含了局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写到方法表的Code属性中，所以一个栈帧需要多大内存，不会受到程序运行期变量数据的影响，仅取决于虚拟机内部实现。

一个线程中的方法调用链可能很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程里，只有位于栈顶的栈帧才是有效的，称为当前帧(Current Stack Frame)，与这个栈帧相关联的方法称为当前方法(current Method)。执行引擎运行的所有字节码指令都只针对于当前帧进行操作。

| 当前线程 | 线程2 | 线程n |
| -------- | ----- | ----- |
| 当前栈帧 | ...   | ...   |
| 栈帧n    | ...   | ...   |
| 栈帧2    | ...   | ...   |
| 栈帧1    | ...   | ...   |

### 8.2.1 局部变量表

局部变量表(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译位Class文件时，就在方法的Code属性的max_locals数据相中确定了该方法所需要分配的局部变量表的最大容量。

局部变量表的容量以变量槽(Variable Slot，Slot)为最小单位，虚拟机没有明确指明一个Slot应占用的内存空间大小，很有导向性的说每一个Slot都应该能存放一个boolean、byte、char、short、int、float、reference、returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放，允许Slot的长度可以跟随处理器、操作系统或虚拟机的不同而发生变化。只要保证即使在64位虚拟机中使用了64位的物理内存空间去实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致。

一个slot可以存放32位以内的数据类型，Java中占用32位以内的有boolean,byte,char,short,int,float,reference和returnAddress8种类型。(Java语言和JVM的数据类型存在本质差别)，reference类型表示对一个对象实例的引用，虚拟机规范没有规定长度和怎样的数据结构，但一般实现两点：1、从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引，2、此引用中直接或间接的查找到对象所属数据类型在方法区中的存储的类型信息。returnAddress很少见，为jsr,jsr_w和ret服务的，指向了一条字节码指令地址，古老的jvm用这些指令实现异常处理，现在用异常表代替。

(reference没有规定长度，32位还是64位与虚拟机有关，如果是64位虚拟机还与是否开启某些对象指针压缩的优化有关，所以可能是32位的也可能是64位的)

64位数据类型，虚拟机用高位对齐的方式为其分配两个连续的slot空间，Java语言明确的64位的数据类型只有long和double两种。long和double数据类型分割存储与"long和double的非原子性协定"中把一次long和double数据类型读写分割为两次32位读写的做饭类似。由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的slot是否为原子操作，都不会引起数据安全问题。

