# 第八章 虚拟机字节码执行引擎

## 8.1 概述

执行引擎是JVM最核心的组成部分之一。

物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的。

虚拟机的执行引擎由自己实现，可以自行定制指令集和执行引擎的结构体系，能够执行不被硬件直接支持的指令集格式。 

JVM规范中制定了虚拟机字节码执行引擎的概念模型，称为各个虚拟机执行引擎的统一外观(Facade

)。在不同的虚拟机实现里，执行引擎在执行Java代码时可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，也可能包含几个不同级别的编译器执行引擎。但外观上看，所有JVM的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

## 8.2 运行时栈帧结构

栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

每一个栈帧都包含了局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写到方法表的Code属性中，所以一个栈帧需要多大内存，不会受到程序运行期变量数据的影响，仅取决于虚拟机内部实现。

一个线程中的方法调用链可能很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程里，只有位于栈顶的栈帧才是有效的，称为当前帧(Current Stack Frame)，与这个栈帧相关联的方法称为当前方法(current Method)。执行引擎运行的所有字节码指令都只针对于当前帧进行操作。

| 当前线程 | 线程2 | 线程n |
| -------- | ----- | ----- |
| 当前栈帧 | ...   | ...   |
| 栈帧n    | ...   | ...   |
| 栈帧2    | ...   | ...   |
| 栈帧1    | ...   | ...   |

### 8.2.1 局部变量表

局部变量表(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译位Class文件时，就在方法的Code属性的max_locals数据相中确定了该方法所需要分配的局部变量表的最大容量。

局部变量表的容量以变量槽(Variable Slot，Slot)为最小单位，虚拟机没有明确指明一个Slot应占用的内存空间大小，很有导向性的说每一个Slot都应该能存放一个boolean、byte、char、short、int、float、reference、returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放，允许Slot的长度可以跟随处理器、操作系统或虚拟机的不同而发生变化。只要保证即使在64位虚拟机中使用了64位的物理内存空间去实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致。

一个slot可以存放32位以内的数据类型，Java中占用32位以内的有boolean,byte,char,short,int,float,reference和returnAddress8种类型。(Java语言和JVM的数据类型存在本质差别)，reference类型表示对一个对象实例的引用，虚拟机规范没有规定长度和怎样的数据结构，但一般实现两点：1、从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引，2、此引用中直接或间接的查找到对象所属数据类型在方法区中的存储的类型信息。returnAddress很少见，为jsr,jsr_w和ret服务的，指向了一条字节码指令地址，古老的jvm用这些指令实现异常处理，现在用异常表代替。

(reference没有规定长度，32位还是64位与虚拟机有关，如果是64位虚拟机还与是否开启某些对象指针压缩的优化有关，所以可能是32位的也可能是64位的)

64位数据类型，虚拟机用高位对齐的方式为其分配两个连续的slot空间，Java语言明确的64位的数据类型只有long和double两种。long和double数据类型分割存储与"long和double的非原子性协定"中把一次long和double数据类型读写分割为两次32位读写的做饭类似。由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的slot是否为原子操作，都不会引起数据安全问题。

虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果访问的是32位数据类型的变量，索引n就代表使用第n个slot，如果是64位数据类型的变量，则说明会同时使用n和n+1两个slot。对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中某一个，JVM规范明确要求了如果遇到进行这种操作的字节码序列，虚拟机应当在类加载的校验阶段抛出异常。

在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果是执行的是实例方法(非static方法)，局部变量表第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以使用关键字this来访问到这个隐含的参数。其余参数按照参数表的顺序排列，占用从1开始的局部变量表slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。

为了尽可能的节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域不一定覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用。不过，这样可以节省栈帧空间外，副作用，某些情况下，slot复用会直接影响到系统的垃圾回收行为。

示例：略。placeholder能否被回收的根本原因是：局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中虽然代码离开了作用域，但在此之外，没有任何对局部变量表的读写操作，placeholder原本占用的slot还没有被其他变量复用，所以作为GC Roots一部分的局部变量表仍然保持着对placeholder的关联。作为一种特殊情况(对象占用内存大、方法的栈帧长时间不能回收、方法调用次数达不到JIT的编译条件)，一种奇技，"不使用的对象应手动赋值null"。

但不应对赋null有过多的依赖，更没必要作为编码规则。原因两点，1、编码角度，适当的变量作用域来控制变量回收时间才是最优雅的解决办法。2、更关键的执行角度，使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，概念模型与实际执行过程是外部看起来等效，内部看上去完全不同。虚拟机使用解释器执行时，通常与概念模型比较接近，但经过JIT编译器后，才是虚拟机执行代码的主要方式，赋null值的操作在经过JIT编译优化后就会被消除掉，这时变量赋null没有意义。字节码被编译位本地代码后，对GC Roots的枚举也与解释执行时期有巨大差别，经过JIT编译后，System.gc()执行时就能正确的回收掉内存。

关于局部变量表，还有一点对实际开发有影响，局部变量不像类变量存在"准备阶段"(类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始化值；另一次在初始化阶段，赋予程序员定义的初始值)。因此，初始化阶段程序员没有为类变量赋值也没关系，类变量仍然具有一个确定的初始值。但局部变量不一样，如果一个局部变量定义了却没有赋初始值是不能使用的，不要认为Java任何情况都存在诸如整型变量默认为0，布尔型变量默认为false等这样的默认值。

```
public static void main(String[] args){
  int a;
  System.out.println(a);
}
```

上面的代码是运行不了的，编译器在编译阶段就能检查到并提示，即使编译通过或者手动生成字节码的方式制造出上面的代码效果，字节码校验的时候也会被虚拟机发现而导致类加载失败。

### 8.2.2 操作数栈

也称为操作栈，是一个后入先出(Last in first out,lifo)栈。操作数栈最大深度在编译时写入COde属性max_stacks数据项中。操作数栈每一个元素都可以是任意Java数据类型，long、double。32位占栈容量为1，64位为2.方法执行的时候，操作数栈的深度不会超过max_stacks设定的最大值。

整数加法的字节码指令iadd在运行时，操作数栈中最接近栈顶的两个元素已经存入两个int型数值，执行指令时，会将两个int值出栈并相加，然后把相加的结果入栈。

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，编译器保证，类校验阶段的数据流分析再验证。iadd指令用于整型数相加，在执行时，最接近栈顶的两个元素的数据类型必须为int，不能出现一个long和一个float使用iadd相加的情况。

在概念模型里，两个栈帧作为虚拟机栈的元素是完全独立的。大多数虚拟机在实现里都会做一些优化，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，进行方法调用时可以共用一部分数据，无需额外的参数复制传递。

jvm执行的解释执行引擎称为"基于栈的执行引擎"，栈就是操作数栈。

### 8.2.3 动态链接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接(Dynamic Linking)。

Class文件的常量池存有大量的符号引用，字节码中的方法调用指令就以常量池指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，称为静态解析。另一部分在每一次运行期间转化为直接引用，称为动态链接。

### 8.2.4 方法返回地址

当一个方法执行后，只有两种方式可以退出这个方法。

1. 执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，叫正常完成出口(Normal Method Invocation Completion ).
2. 在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是jvm内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出称为异常完成退出(Abrupt Method Invocation Completion) 。

无论何种退出方式，在方法退出之后，都需要返回方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来恢复上层方法的执行状态。一般来说，方法正常退出，调用者PC计数器的值可作为返回地址，栈帧中中很可能会保存这个计数器值。而方法异常退出时，返回地址通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。

方法退出的过程实际上等同于把当前的栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如有)压入调用者· 栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。

### 8.2.5 附加信息

虚拟机规范允许虚拟机具体实现时 增加一些规范里没有描述的信息到栈帧之中，取决于虚拟机的实现。实际开发过程中，一般会把动态链接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。

