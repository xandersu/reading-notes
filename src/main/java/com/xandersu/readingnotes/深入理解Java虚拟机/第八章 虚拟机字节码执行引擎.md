# 第八章 虚拟机字节码执行引擎

## 8.1 概述

执行引擎是JVM最核心的组成部分之一。

物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的。

虚拟机的执行引擎由自己实现，可以自行定制指令集和执行引擎的结构体系，能够执行不被硬件直接支持的指令集格式。 

JVM规范中制定了虚拟机字节码执行引擎的概念模型，称为各个虚拟机执行引擎的统一外观(Facade

)。在不同的虚拟机实现里，执行引擎在执行Java代码时可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，也可能包含几个不同级别的编译器执行引擎。但外观上看，所有JVM的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

## 8.2 运行时栈帧结构

栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

每一个栈帧都包含了局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写到方法表的Code属性中，所以一个栈帧需要多大内存，不会受到程序运行期变量数据的影响，仅取决于虚拟机内部实现。

一个线程中的方法调用链可能很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程里，只有位于栈顶的栈帧才是有效的，称为当前帧(Current Stack Frame)，与这个栈帧相关联的方法称为当前方法(current Method)。执行引擎运行的所有字节码指令都只针对于当前帧进行操作。

| 当前线程 | 线程2 | 线程n |
| -------- | ----- | ----- |
| 当前栈帧 | ...   | ...   |
| 栈帧n    | ...   | ...   |
| 栈帧2    | ...   | ...   |
| 栈帧1    | ...   | ...   |

### 8.2.1 局部变量表

局部变量表(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译位Class文件时，就在方法的Code属性的max_locals数据相中确定了该方法所需要分配的局部变量表的最大容量。

局部变量表的容量以变量槽(Variable Slot，Slot)为最小单位，虚拟机没有明确指明一个Slot应占用的内存空间大小，很有导向性的说每一个Slot都应该能存放一个boolean、byte、char、short、int、float、reference、returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放，允许Slot的长度可以跟随处理器、操作系统或虚拟机的不同而发生变化。只要保证即使在64位虚拟机中使用了64位的物理内存空间去实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致。

一个slot可以存放32位以内的数据类型，Java中占用32位以内的有boolean,byte,char,short,int,float,reference和returnAddress8种类型。(Java语言和JVM的数据类型存在本质差别)，reference类型表示对一个对象实例的引用，虚拟机规范没有规定长度和怎样的数据结构，但一般实现两点：1、从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引，2、此引用中直接或间接的查找到对象所属数据类型在方法区中的存储的类型信息。returnAddress很少见，为jsr,jsr_w和ret服务的，指向了一条字节码指令地址，古老的jvm用这些指令实现异常处理，现在用异常表代替。

(reference没有规定长度，32位还是64位与虚拟机有关，如果是64位虚拟机还与是否开启某些对象指针压缩的优化有关，所以可能是32位的也可能是64位的)

64位数据类型，虚拟机用高位对齐的方式为其分配两个连续的slot空间，Java语言明确的64位的数据类型只有long和double两种。long和double数据类型分割存储与"long和double的非原子性协定"中把一次long和double数据类型读写分割为两次32位读写的做饭类似。由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的slot是否为原子操作，都不会引起数据安全问题。

虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果访问的是32位数据类型的变量，索引n就代表使用第n个slot，如果是64位数据类型的变量，则说明会同时使用n和n+1两个slot。对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中某一个，JVM规范明确要求了如果遇到进行这种操作的字节码序列，虚拟机应当在类加载的校验阶段抛出异常。

在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果是执行的是实例方法(非static方法)，局部变量表第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以使用关键字this来访问到这个隐含的参数。其余参数按照参数表的顺序排列，占用从1开始的局部变量表slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。

为了尽可能的节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域不一定覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用。不过，这样可以节省栈帧空间外，副作用，某些情况下，slot复用会直接影响到系统的垃圾回收行为。

示例：略。placeholder能否被回收的根本原因是：局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中虽然代码离开了作用域，但在此之外，没有任何对局部变量表的读写操作，placeholder原本占用的slot还没有被其他变量复用，所以作为GC Roots一部分的局部变量表仍然保持着对placeholder的关联。作为一种特殊情况(对象占用内存大、方法的栈帧长时间不能回收、方法调用次数达不到JIT的编译条件)，一种奇技，"不使用的对象应手动赋值null"。

但不应对赋null有过多的依赖，更没必要作为编码规则。原因两点，1、编码角度，适当的变量作用域来控制变量回收时间才是最优雅的解决办法。2、更关键的执行角度，使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，概念模型与实际执行过程是外部看起来等效，内部看上去完全不同。虚拟机使用解释器执行时，通常与概念模型比较接近，但经过JIT编译器后，才是虚拟机执行代码的主要方式，赋null值的操作在经过JIT编译优化后就会被消除掉，这时变量赋null没有意义。字节码被编译位本地代码后，对GC Roots的枚举也与解释执行时期有巨大差别，经过JIT编译后，System.gc()执行时就能正确的回收掉内存。

关于局部变量表，还有一点对实际开发有影响，局部变量不像类变量存在"准备阶段"(类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始化值；另一次在初始化阶段，赋予程序员定义的初始值)。因此，初始化阶段程序员没有为类变量赋值也没关系，类变量仍然具有一个确定的初始值。但局部变量不一样，如果一个局部变量定义了却没有赋初始值是不能使用的，不要认为Java任何情况都存在诸如整型变量默认为0，布尔型变量默认为false等这样的默认值。

```
public static void main(String[] args){
  int a;
  System.out.println(a);
}
```

上面的代码是运行不了的，编译器在编译阶段就能检查到并提示，即使编译通过或者手动生成字节码的方式制造出上面的代码效果，字节码校验的时候也会被虚拟机发现而导致类加载失败。

### 8.2.2 操作数栈

