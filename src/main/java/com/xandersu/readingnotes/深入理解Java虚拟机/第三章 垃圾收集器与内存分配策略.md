# 第三章 垃圾收集器与内存分配策略

## 3.2 对象已死吗

垃圾收集器进行回收前，需要判断哪些对象还活着，哪些对象已经死去（即不可能再被任何途径使用的对象）

### 3.2.1 引用计数法

主流的Java虚拟机里没有选用引用计数器算法来实现管理内存，主要原因：很难解决对象之间的**循环引用**的问题。

### 3.2.2 可达性分析算法

主流商用程序语言（Java、C#、Lisp）通过可达性分析（Reachability Analysis）来判定对象是否活着。基本思路，通过一系列的称为“GC Roots” 的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，证明对象时不可用的。

Java语言中，可作为GC Roots的对象包括：

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法中JNI（Native方法）引用的对象

### 3.2.3 再谈引用

JDK1.2之前，Java引用定义：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称为这块内存代表着一个引用。

JDK1.2之后，对引用概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用 （Phantom Reference）。

- 强引用指程序代码中普遍存在的，new，只要强引用还在垃圾回收器永远不会回收掉引用的对象。
- 软引用用来描述一些还有用但并非必需的对象，软引用的对象，在系统将要放生内存溢出异常前，将这些对象列进回收范围之中进行第二次回收，如果本次回收仍未有足够的内存，才会抛出内存溢出异常。JDK1.2之后，SoftReference类实现软引用。
- 弱引用用来描述非必需对象，强度比弱引用弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生之前。进行垃圾回收时，无论当时内存是否足够，都会回收掉弱引用关联的对象。WeakReference类实现。
- 虚引用，一个对象是否有虚引用的存在，不影响其生存的时间，也无法通过一个虚引用来取得一个对象实例。设置虚引用唯一目的，能在这个对象被收集器收集之前收到一个人系统通知。PhantomReference

### 3.2.4 生存还是死亡

真正宣告一个对象死亡，至少要经历两次标记过程：

对象在进行可达性分析后发现没有与GC Roots相连接的引用链，他将被第一次标记并进行一次筛选，筛选条件是此时该对象是否有必要执行finalize()方法。当对象没有覆盖finalize方法、或者方法被JVM调用过，虚拟机都认为没有必要执行。

如果对象被判定有必要执行finalize方法，这个对象会放置在一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动创建的低优先级的Finalizer线程去执行它。虚拟机会触发finalize方法，但不保证会等待方法执行结束。finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC会对F-Queue中的对象进行第二次小规模标记，如果要在finalize方法拯救自己——重新与引用链上任何一个对象建立关联，那么它在第二次标记时将被移出“即将回收”集合，如果仍然没有逃脱，则被回收。

1. 对象可以在被GC时自我拯救
2. 这种自救机会只有一次，因为一个对象的finalize方法最多会被系统自动调用一次

特别说明，finalize运行代价高昂、不确定性大、无法保证各个对象的调用顺序，建议忘掉这个方法。

### 3.2.5 回收方法区

jvm规范里不要求在方法区实现垃圾收集，而且方法区垃圾收集性价比低。

永久代的垃圾收集主要两部门：废弃常量和无用的类。

常量与堆中对象相似。

判断无用的类条件苛刻：

- 该类所有的实例都已经被回收，Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反访问该类的方法。

满足上述3点，可以被回收，但不是必然被回收。

HotSpot 虚拟机提供 -Xnoclassgc参数进行控制，可以使用-verbose:class 和 -XX:+TraceClassLoading , -XX:+TraceClassUnloading查看类加载和卸载信息。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OGSi这类频繁自定义ClassLoader的场景度需要虚拟机有类卸载的功能，以保证永久代不会溢出。

## 3.3 垃圾收集算法

### 3.3.1 标记-清除算法

标记-清除（Mark-Aweep）算法，最基础，算法分为“标记”和“清除”两个阶段：首先标记除所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

两个不足：

1. 效率，标记和清除两个过程效率都不高；
2. 空间问题，标记清除后会产生大量不连续的内存碎片，可能会导致需要分配较大的对象时，无法找到足够的连续内存二不得不提前触发另一次垃圾收集动作。

### 3.3.2 复制算法

复制（Copying）算法：将可用内存划按容量分成大小相等的两块，每次只使用其中的一块。当其中一块内存用完后，将还存活的对象复制到另外一块，再把已使用过的内存空间一次清理掉。

不足：内存缩小为原来的一半。

将内存分为较大的Eden空间和两块较小的survivor空间，每次使用Eden和其中一块survivor，当回收时，将eden区和survivor区中还活着的对象一次性的复制到另外一块survivor区，最后清理掉Eden区和刚用过的survivor区。HotSpot默认Eden和survivor大小比例：8：1。

当survivor空间不够时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）。

### 3.3.3 标记-整理算法

复制算法在对象存活率较高时需要额外进行较多的复制操作，效率会变低。老年代没有分配担保，一般不直接选用复制算法。

标记-整理（Mark-Compact）算法，，标记后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一段移动，直接清理掉端边界以外的内存。

### 3.3.4 分代收集算法

分代收集（Generational Collection）算法，根据对象存活周期的不同把内存分为几块，一般把Java堆分为新生代和老年代，新生代，对存活的少选用复制算法，老年代对象存活率高、没有额外的分配担保，就使用“标记清理”和标记整理。

## 3.4 HotSpot的算实现

可达性分析

必须在一个能确保一致性的快照中进行。导致GC必须停顿所有Java执行线程（Stop the world）。

OopMap

### 3.4.2 安全点

Safepoint，程序执行时并非所有地方都停顿下来开始GC，只有到达安全点时才暂停。

如何在GC发生时让所有线程（不包括jni线程）都跑到最近的安全点再停下来，两种方案：抢先式中断（Preemptive Suspension）和主动式中断(Voluntary Suspension)

1. 抢先式中断:GC发生时，所有线程都中断，如果线程中断不在安全点上，恢复线程，跑到安全点上。几乎没有虚拟机使用。
2. 主动式中断：GC需要中断线程时，不直对线程进行操作，设置标志，各个线程执行时主动轮询标志，发现中断标志为真就自己中断挂起。轮询标志的地方与安全点重合，另外创建对象需要分配内存的时候。

### 3.4.3 安全区域

程序没有分配CPU时间，处于Sleep和Blocked状态，线程无法响应JVM的中断请求，到安全点中断挂起，需要安全区域（Safe Region）解决。

安全区域指一段代码判断中，引用关系不在发生变化，在这个区域任意地方开始GC都是安全的。

线程执行到Safe Region时，表示自己进入了Safe Region，当线程要离开Safe Region时，要检查系统是否完成了根节点枚举，如果完成了就继续执行，否则要等到收到离开信号才行。

## 3.5 垃圾收集器

### 3.5.1 Serial收集器

单线程的收集器，只会使用一个CPU或者一条收集线程去完成垃圾收集的工作，工作时必须暂停所有工作线程，直到收集结束。

client模式下新生代很好的选择。

### 3.5.2 ParNew收集器

Serial收集器多线程版本。

server模式新生代首选的收集器。只有他能与CMS收集器配合工作。

### 3.5.3 Parallel Scavenge 收集器

新生代收集器，复制算法，

CMS关注点是缩短GC时用户等待时间。

 Parallel Scavenge关注点是达到一个可控制的吞吐量（Throughput）。吞吐量=运行用户代码时间/（运行用户代码时间+GC时间）。

吞吐量优先收集器

-XX:+UseAdaptiveSizePolicy开关参数，打开后。不需要手动指定新生代大小、Eden和Survivor区的比例、晋升老年代对象的大小等细节参数，虚拟机动态调整以提供最合适的停顿时间或者最大的吞吐量，称为GC自适应的调节策略（GC Ergonomics）。

### 3.5.4 Serial old 收集器

Serial收集器的老年代版本，主要给client老年代用，server模式下，两个作用：1、JDK 1.5之后搭配Parallel Scavenge 使用。2、CMS收集器的后背预案。

### 3.5.5 Parallel Old 收集器

 Parallel Scavenge 收集器老年代版本，多线程和标记整理法，JDK1.6之后提供。

Parallel Scavenge只能和Serial old 使用，老年代GC在服务端性能拖累。

### 3.5.6 CMS收集器

CMS（Concurrent Mark Sweep）收集器，一种以获取最短回收停顿时间为目标的收集器。

运作四个步骤：

1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS mark）
4. 并发清除（CMS concurrent sweep）

初始标记和重新标记需要暂停。初始标记值标记GC root是能直接关联到的对象，速度很快，并发标记阶段是进行Gc roots tracing 的过程，重新标记为了修正并发标记期间因为程序运作而导致标记产生变动的那一部分对象，比初始标记长，比并发标记短。

总体上，CMS内存回收过程是与用户线程一起并发执行的。

并发收集、低停顿。

3个明显缺点：

1. 对CPU资源敏感。默认启动线程数是（cpu数量+3）/4。
2. 无法处理浮动垃圾（Floating Garbage）。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC产生。
   浮动垃圾：由于CMS并发清理阶段用户线程还在运行，系统会产生新的垃圾，这部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉他们，只好留在下一次GC时再清理。
   由于CMS垃圾收集过程中用户线程还在运行，需要预留足够的内存给用户线程使用，CMS不能像其他收集器那样在老年代几乎填满时进行收集。JDK1.5默认老年代高于68%会被激活，可以调高参数-XX:CMSInitiatingOccupancyFraction提供触发的百分比。JDK1.6提升到92%。如果CMS运行期间预留的内存无法满足程序需要，就会出现COncurrent Mode Failure失败，虚拟机会启动后备预案，临时启用Serial Old收集器重新进行老年代收集，停顿时间变长，降低性能。
3. CMS时标记-清除法，收集结束后会有大量碎片产生。CMS提供-XX:+UseCMSCompactAtFullCollection开关参数（默认开启），用于CMS Full GC时开启内存碎片合并整过程，停留时间变长。-XX:CMS
4. FullGCsBeforeCompaction参数，用于执行多少次不压缩的Full GC后来一次压缩（默认0，每次Full GC都进行碎片整理）。

### 3.5.1 G1收集器

G1（Garbage-First）面向服务端，目的代替cms收集器。特点：

- 并行与并发：充分利用多CPU多核心缩短停顿时间。
- 分代收集：独立管理整个GC堆。
- 空间整合：G1整体上时“标记-整理”算法，局部看，两个（region）基于复制。G1运行时不会产生内存碎片。
- 可预测的停顿：低停顿，建立可预测的停顿时间模型，让使用者明确指定在长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。几乎是实时Java（RTSJ）的垃圾收集器特征了。

G1前的收集器收集范围是整个新生代或老年代，G1收集java堆布局与其他收集器有差别，将整个Java堆换分成多个大小相等的独立区域（region），新生代和老年代不在物理隔离，都是一部分Region（不需要连续）的集合。

G1之所以能建立可预测的停顿时间模型，是因为有计划的避免Java堆进行全区域的垃圾收集，G1跟踪各个Region离得垃圾堆积的价值大小，后台维护一个优先列表，根据允许的收集时间优先回收价值最大的Region，保证了G1在优先的时间可以尽可能高的收集效率。

G1收集器中，Region之间的对象引用，都是使用Remembered Set来避免全堆扫描。G1每个Region都有对应的Remembered Set，虚拟机发现程序对Refrence类型进行写操作时，会产生一个Write Barrier 暂时中断写操作，检查Refrence引用的对象是否处于不同的Region之中，是，就通过CardTable把相关引用信息记录到内引用的对象所属Region的Remembered Set中。进行内存回收时，GC各节点的枚举范围中加入Remembered Set即可保证不对全堆进行扫描也不会有遗漏。

不把维护Remembered Set计算在内，G1的运作步骤：

- 初始标记（Initial Marking）
- 并发标记（Concurrent Marking）
- 最终标记（Final Mark）
- 筛选回收（Live Data Counting and Evacuation）

初始标记指示标记一下GC Roots能直接关联到的对象，并正确的修改TAMS(next top at marking start)的值，让下一阶段程序并发执行的时候，能在正确可用的Region创建对象，需要暂停线程，时间很短。并发标记阶段从GC Roots开始对堆中对象进行可达性分析，耗时较长，但可并发执行。最终标记阶段为了修正在并发标记期间因用户程序继续运作而导致标记产生变化的那一部分标记记录，虚拟机将这段时间内的对象变化记录在线程Remembered Set logs里，最终标记阶段吧Remembered Set Logs合并到Remembered Set中，需要停顿线程，蛋壳并行执行。最后筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间来指定回收计划，因为只回收一部分Region时间使用户控制的。

### 3.5.8 理解GC日志

Serial收集器新生代名字Default New Generation，显示DefNew。

ParNew收集器，新生代名字为ParNew，意为Parallel New Generation.

Parallel Scavenge收集器，PSYoungGen。

## 3.6 内存分配和回收策略

Java自动内存管理为自动化解决两个问题：给对象分配内存以及回收分配给对象的内存。

对象的内存分配，在堆上分配（JIT编译后拆散为标量类型并间接地栈上分配），对象主要分配在新生代Eden区，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下可直接分配在老年代。

### 3.6.1 对象优先在Eden分配

大多数情况下，对象在新生代Eden区分配。Eden区没有足够的空间进行分配时虚拟机将发起一次Minor GC。

虚拟机提供了-XX:PrintGCDetails收集器日志参数，在发生垃圾收集时打印内存回收日志，并且在进程退出时输出当前内存各区域分配情况。

minor GC，新生代GC，minor GC非常频繁，回收速度比较快。

Full GC/Major GC，老年代GC，出现老年代GC经常会伴随至少一次minor GC（非绝对），比minor GC慢10倍以上

### 3.6.2 大对象直接进入老年代

大对象，需要连续内存空间的Java对象。经常出现大对象会导致内存还有很多空间时提前触发垃圾收集以获取足够连续空间来安置。

### 3.6.3 长期存活的对象将进入老年代

虚拟机给每个对象定义了一个对象年龄（Age）计数器。对象在Eden出生并经过第一次minor GC后仍让存活并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设定为1。对象在Survivor中每熬过一次minor GC年龄增长1，到达一定年龄（默认15岁），就会晋升到老年代中。-X:MaxTenuringThreshold设置。

### 3.6.4 动态对象年龄判定

如果在Survivor空间之中相同年龄的对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold要求的年龄。

### 3.6.5 空间分配担保

发生minor GC之前，虚拟机会检查老年大最大可用连续空间是否大于新生代所有对象总空间，如果成立，minor GC可以确保安全。如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，会尝试进行一次minor GC，尽管有风险；如果小于，或者HandlePromotionFailure设置不允许冒险，那这是也要改为进行一次Full GC。

JDK6 update 24之后规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行minor GC，否则进行Full GC。
