# 第七章 虚拟机类加载机制

## 7.1 概述

虚拟机类的加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

Java语言里，类的加载、连接和初始化过程都是在程序运行阶段完成的，类加载时增加一些性能开销，为Java应用提高灵活性。Java语言可以动态扩展的语言特性，运行期动态加载和动态链接。

## 7.2 类加载的时机

类加载到卸载的生命周期：加载(Loading)、验证(Vertification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。验证、准备、解析3个部分统称为连接(Linking)。

加载、验证、准备、初始化和卸载5个阶段顺序是确定的，按顺序按部就班的开始。解析阶段不一定：某些情况下可以在初始化阶段之后在开始，为了支持Java语言运行时绑定(动态绑定或晚期绑定)。

JVM规范没有规定什么时候再是类加载的第一个阶段。

初始化阶段，JVM规定有且只有5种情况必须立即进行"初始化"：

1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行初始化，则需先触发其初始化。场景：new关键字实例化对象、读取或设置一个类的静态字段、调用一个类的静态方法时。
2. 使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行初始化，则需先触发其初始化。
3. 当初始化一个类时，如果发现其父类还没有进行过初始化，需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main方法的类)，虚拟机会先初始化这个类。
5. 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析结果REF_getstatic、REF_putstatic、REF_invokestatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，需要先触发初始化。

虚拟机使用**有且仅有**。这5总场景的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。

对于静态字段，只有直接定义这个字段的类才会被初始化，所以子类引用父类定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

`SuperClass[] sca = new SuperClass[10] `

运行后发现，没有触发SuperClass的类的初始化阶段。但出发了另外一个名叫`[Lxxx.xxx.SuperClass`的类的初始化阶段，这是由虚拟机自动生成的、直接继承与java.lang.Object的子类，创建动作由字节码指令newarray触发。代表了元素类型为xxx.xxx.SuperClass的一维数组。

虽然在Java源码里引用了类中的常量HELLOWORLD，但在编译阶段通过常量的传播优化，将该常量的值存储到使用的类的常量池中，之后对HELLOWORLD常量的引用都是对自身常量池的引用。

接口的加载和类的加载稍有不同。接口也有初始化过程，编译器仍然会生成`<clinit>()`类构造器，用于初始化接口中所定义的成员变量。接口和类真正有区别的是5种初始化场景的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口初始化时，并不要求其父接口全部都完成初始化，只有在真正使用到父接口的时候才会初始化。

## 7.3 类加载的过程

类加载的全过程：加载、验证、准备、解析、初始化。

### 7.3.1 加载

加载时类加载(Class Loading)过程的一个阶段。加载阶段，虚拟机需要完成3件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

通过一个类的全限定名来获取定义此类的二进制字节流，没有指明二进制字节流要从哪里、怎样获取：

- 从ZIP包中获取，日后JAR、EAR、WAR格式的基础
- 从网络中获取，Applet
- 运行时计算生成，动态代理技术
- 由其他文件生成，JSP
- 从数据库读取，中间件服务器

非数组类的加载阶段可以使用系统提供的引导类加载器来完成，由用户自己自定义的类加载器完成。

对于数组类而言，不是通过类加载器创建，是由JVM直接创建的。但数组类的元素类型(Element Type,指的是数组去掉所有维度的类型)最终是要通过类加载器去创建。

一个数组类(简称C)创建过程遵循以下规则：

- 如果数组的组件类型(Component Type,指的是数组去掉一个维度的类型)是引用类型，那就递归采用加载过程去加载这个组件，数组C将在加载该组件类型的类加载器的类名称空间上被标识(一个类必须与类加载器一起确定唯一性)
- 如果数组的组件类型不是引用类型(如int[]数组)，JVM将会把数组C标记为与引导类加载器关联。
- 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认为public。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区的数据存储格式由虚拟机实现自行定义，JVM规范并没有规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象(并没有规定在Java堆中，对于HotSpot而言，Class对象比较特殊，存放在方法区里面)，这个对象作为程序访问方法区中的这些类型数据的外部接口。

加载阶段和连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中的动作仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

