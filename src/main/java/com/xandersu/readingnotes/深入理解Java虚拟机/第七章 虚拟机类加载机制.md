# 第七章 虚拟机类加载机制

## 7.1 概述

虚拟机类的加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

Java语言里，类的加载、连接和初始化过程都是在程序运行阶段完成的，类加载时增加一些性能开销，为Java应用提高灵活性。Java语言可以动态扩展的语言特性，运行期动态加载和动态链接。

## 7.2 类加载的时机

类加载到卸载的生命周期：加载(Loading)、验证(Vertification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。验证、准备、解析3个部分统称为连接(Linking)。

加载、验证、准备、初始化和卸载5个阶段顺序是确定的，按顺序按部就班的开始。解析阶段不一定：某些情况下可以在初始化阶段之后在开始，为了支持Java语言运行时绑定(动态绑定或晚期绑定)。

JVM规范没有规定什么时候再是类加载的第一个阶段。

初始化阶段，JVM规定有且只有5种情况必须立即进行"初始化"：

1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行初始化，则需先触发其初始化。场景：new关键字实例化对象、读取或设置一个类的静态字段、调用一个类的静态方法时。
2. 使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行初始化，则需先触发其初始化。
3. 当初始化一个类时，如果发现其父类还没有进行过初始化，需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main方法的类)，虚拟机会先初始化这个类。
5. 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析结果REF_getstatic、REF_putstatic、REF_invokestatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，需要先触发初始化。

虚拟机使用**有且仅有**。这5总场景的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。

对于静态字段，只有直接定义这个字段的类才会被初始化，所以子类引用父类定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

`SuperClass[] sca = new SuperClass[10] `

运行后发现，没有触发SuperClass的类的初始化阶段。但出发了另外一个名叫`[Lxxx.xxx.SuperClass`的类的初始化阶段，这是由虚拟机自动生成的、直接继承与java.lang.Object的子类，创建动作由字节码指令newarray触发。代表了元素类型为xxx.xxx.SuperClass的一维数组。

虽然在Java源码里引用了类中的常量HELLOWORLD，但在编译阶段通过常量的传播优化，将该常量的值存储到使用的类的常量池中，之后对HELLOWORLD常量的引用都是对自身常量池的引用。

接口的加载和类的加载稍有不同。接口也有初始化过程，编译器仍然会生成`<clinit>()`类构造器，用于初始化接口中所定义的成员变量。接口和类真正有区别的是5种初始化场景的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口初始化时，并不要求其父接口全部都完成初始化，只有在真正使用到父接口的时候才会初始化。

## 7.3 类加载的过程

类加载的全过程：加载、验证、准备、解析、初始化。

### 7.3.1 加载

加载时类加载(Class Loading)过程的一个阶段。加载阶段，虚拟机需要完成3件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

通过一个类的全限定名来获取定义此类的二进制字节流，没有指明二进制字节流要从哪里、怎样获取：

- 从ZIP包中获取，日后JAR、EAR、WAR格式的基础
- 从网络中获取，Applet
- 运行时计算生成，动态代理技术
- 由其他文件生成，JSP
- 从数据库读取，中间件服务器

非数组类的加载阶段可以使用系统提供的引导类加载器来完成，由用户自己自定义的类加载器完成。

对于数组类而言，不是通过类加载器创建，是由JVM直接创建的。但数组类的元素类型(Element Type,指的是数组去掉所有维度的类型)最终是要通过类加载器去创建。

一个数组类(简称C)创建过程遵循以下规则：

- 如果数组的组件类型(Component Type,指的是数组去掉一个维度的类型)是引用类型，那就递归采用加载过程去加载这个组件，数组C将在加载该组件类型的类加载器的类名称空间上被标识(一个类必须与类加载器一起确定唯一性)
- 如果数组的组件类型不是引用类型(如int[]数组)，JVM将会把数组C标记为与引导类加载器关联。
- 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认为public。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区的数据存储格式由虚拟机实现自行定义，JVM规范并没有规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象(并没有规定在Java堆中，对于HotSpot而言，Class对象比较特殊，存放在方法区里面)，这个对象作为程序访问方法区中的这些类型数据的外部接口。

加载阶段和连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中的动作仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

### 7.3.2 验证

验证是连接阶段的第一步，目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身。

验证阶段的工作量在虚拟机的类加载子系统中又占了相当大的一部分。

整体上看，大致4个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。

1. 文件格式验证
   第一阶段验证字节码流是否符合Class文件格式的规范，并且能被当前版本的虚拟机出库。

   - 是否以魔数0xCAFEBABY开头。
   - 主、次版本号是否在当前虚拟机处理范围之内。
   - 常量池的常量中是否有不被支持的常量类型(检查常量tag标志)。
   - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
   - CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。
   - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
   - 等等...

   该验证阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这段是基于二进制字节流进行的，通过这个阶段验证，字节流才会进入内存的方法区中进行存储，后面3个验证阶段全部基于方法区的存储结构进行的，不会再直接操作字节流。

2. 元数据验证
   第二阶段是对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求。

   - 这个类是否有父类(除了java.lang.Object，其他所有类都应当有父类)。
   - 这个类的父类是否继承了不允许被继承的类(final修饰的类)
   - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
   - 类中的字段、方法是否与父类产生矛盾(覆盖了父类的final字段、出现了不符合规则的方法重载)
   - 等等...

3. 字节码验证
   第三阶段是最复杂的阶段，目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。第二阶段对元数据信息中的数据类型做校验后，这个阶段是对类的方法体进行校验分析，确保被校验的类在运行时不会做出危害虚拟机安全的事件。

   - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。(例如操作栈放置了int类型的数据，使用时按long类型来加载入本地变量表中)
   - 保证跳转指令不会跳转到方法体以外的字节码指令上。
   - 保证方法体中的类型转换是有效的。
   - 等等...

   由于数据流验证的高复杂性，为了避免过多的时间消耗在字节码验证阶段，JDK1.6后进行了优化，给方法体的Code属性的属性表增加了StackMapTable属性，描述了方法体中所有的基本块(Basic Block,按照控制流拆分的代码块)开始时本地变量表和操作栈应有的状态，在字节码验证的阶段，不会根据程序推导状态的合法性，只需要检查StackMapTable属性中的记录的合法性。

   JDK1.6的hotsp提供了-XX:-UseSplitVertifier选项来关闭这项优化。JDK1.7后，主版本号大于50的Class文件，使用类型检查来完成数据流分析校验是唯一的选择。

4. 符号引用验证
   最后一段校验发生在虚拟机将符号引用转化为直接引用的时候，转化动作在连接的第三阶段——解析阶段发生。符号引用验证可以看做是对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验。

   - 符号引用中通过字符串描述的全限定名是否能找到对应的类。
   - 在指定的类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
   - 符号引用中的类、字段、方法的访问性(private、protected、public、default)
   - 等等...

   符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，将会抛出java.lang.IncompatibleClassChangeError异常的子类。
   对于虚拟机的类加载机制来说，验证阶段非常重要，但不是一定必要的阶段，如果代码已被反复验证过，在实施阶段可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

### 7.3.3 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

这是进行的内存分配仅包括类变量(static)，而不包括实例变量，实例变量将在对象实例化时随着对象一起分配在Java堆中。初始值"通常情况"下是数据类型的零值，例如`public static int value = 123;` 那么value在准备阶段过后的初始值是0而不是234，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器`<clinit>()`方法中，所以赋值123的动作将在初始化阶段才会执行。

Java所有基本数据类型的零值：

| 数据类型 | 零值     |
| -------- | -------- |
| int      | 0        |
| long     | 0L       |
| short    | (short)0 |
| char     | '\u000'  |
| byte     | (byte)0  |
| boolean  | false    |
| float    | 0.0f     |
| double   | 0.0d     |
| refrence | null     |

特殊情况：如果类字段的字段属性表中存在ConstantValue属性，准备阶段value会被初始化为ConstantValue属性所指定的值。加入类变量value定义为：`public static **fianl** int value = 123;` 编译时javac会为vlaue生成ConstantValue属性，准备阶段虚拟机会根据ConstantValue属性的设置将value赋值为123.

### 7.3.4 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在Class文件中以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_MethodRef_info等类型的常量出现。解析阶段中直接引用和符号引用的关联：

- 符号引用(Symbolic References)：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。符号引用的字面量形式明确定义在JVM规范的Class文件格式中。
- 直接引用(Direct References):直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局有关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必然已经在内存当中存在。

虚拟机规范并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield、putstatic这16个用于操作符号引用的字节码指令之前，先对他们所使用的符号引用进行解析。所以虚拟机实现可以根据需要判断是在类加载器加载时就对常量池中的符号引用进行解析还是等到一个符号引用将要被使用前才去解析。

对于同一个符号引用进行多次解析请求很正常，除了invokedynamic指令外，虚拟机实现可以对第一次解析结果进行缓存(在运行时常量池中记录直接引用，并把常量标记为已解析状态)从而避免解析动作重复进行。无论进行多少次解析动作，虚拟机需要保证在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的解析应当一致成功；如果第一次解析失败了，其他指令对这个符号的解析请求也应当收到相同的异常。

invokedynamic指令，规则不成立。invokedynamic指令用于动态语言支持(仅Java语言不会生成这条字节码指令)，它所对应的引用称为"动态调用点限定符"(Dynamic Call Site Specifier)，"动态"含义是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是"静态"的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。

解析动作针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_MethodRef_info、CONSTANT_InterfaceMethodRef_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_InvokeDynamic_info7种常量类型。

#### 1.类或接口的解析

代码所处的类D，要把一个从未解析过的符号引用N解析为一个类或者接口C的直接引用，3个步骤：

1. 如果C不是一个数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程宣告失败。
2. 如果C是一个数组类型，并且数组的元素类型为对象，N描述符是类似"[LJava/lang/Integer"的形式，那么会按照第一点的规则加载数组元素类型，接着由虚拟机生成一个代表此数组唯独和元素的数组对象。
3. 如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为了一个有效的类或者接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果不具备访问权限，抛出java.lang.IllegalAccessError异常。

#### 2. 字段解析

要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index

项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析失败。如果解析完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：

1. 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
2. 否则，如果C中实现了接口，将会按照继承关系从下到上递归搜索各个接口和他的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
3. 否则,如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
4. 否则，查找失败，抛出java.lang.NoSuchFieldError异常。

如果查找成功反回了引用，将会对这个字段进行权限验证，如果不具备访问权限，抛出java.lang.IllegalAccessError异常。

#### 3.类方法解析

第一步与字段解析一样，先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果成功，用C表示这个类，虚拟机按照如下步骤对C进行后续的类方法的搜索：

1. 类方法和接口方法符号引用的常量类型定义是分开的，如果类方法表里发现class_index中索引的C是个接口，直接抛出java.lang.IncompatibleClassChangeError异常。
2. 如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有，则返回这个方法的直接引用，查找结束。
3. 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有，则返回这个方法的直接引用，查找结束。
4. 否则，在类C实现的接口列表及他们的父接口中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有，说明C是个抽象类，这是查找结束，抛出java.lang.AbstractMethodError异常。
5. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。

如果查找成功反回了引用，将会对这个方法进行权限验证，如果不具备访问权限，抛出java.lang.IllegalAccessError异常。

#### 4.接口方法解析

接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果成功，用C表示这个类，虚拟机按照如下步骤进行后续的接口方法搜索：

1. 与类方法解析不同，如果在接口方法表中发现class_info中的索引C是个类而不是接口，直接抛出java.lang.IncompatibleClassChangeError异常.
2. 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有，则返回这个方法的直接引用，查找结束。
3. 否则，在接口C的父接口中递归查找，直到java.lang.Object(查找范围会包括Object类)为止，是否有简单名称和描述符都与目标相匹配的方法，如果有，则返回这个方法的直接引用，查找结束。
4. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。

由于接口所有方法默认public的，不存在访问权限的问题，所以接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。

### 7.3.5 初始化

类初始化阶段是类加载过程的最后一步，除了加载阶段可以通过自定义类加载器参与之外，其余动作都是虚拟机主导和控制。初始化阶段才真正开始执行类中定义的Java程序代码(字节码)。

准备阶段，变量已经赋值过了系统要求的默认值，初始化阶段，根据程序员的程序制定的主管计划去初始化类变量和其他资源。

**初始化阶段是执行类构造器`<clinit>()`方法的过程。**

`<clinit>()`方法是怎么生成的：

- `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(`static{}`)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态代码块中只能访问到定义在静态代码块之前的变量，定义在静态代码块之后的变量，静态代码块中可以赋值，但不能访问。
- `<clinit>()`方法与类的构造函数(实例构造器`<init>()`方法)不同，不需要显式调用父类构造器，虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕。因此虚拟机中第一个被执行`<clinit>()`方法的类肯定是java,.lang.Object。
- 由于父类的`<clinit>()`方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
- `<clinit>()`方法对于类和接口来说并不是必须的，如果一个类没有静态代码块，也没有对变量的赋值操作，编译器可以不为这个类生成`<clinit>()`方法。
- 接口中不能使用静态代码块，但仍然有变量初始化的赋值操作，因此接口和类都会生成`<clinit>()`方法。但接口与类不同的是，执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法。只有父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的`<clinit>()`方法。
- 虚拟机会保证一个类的`<clinit>()`方法再多线程环境下被正确的加锁、同步，如果多线程同时去初始化一个类，那么只有一个线程去执行这个类的`<clinit>()`方法，其他方法都会被阻塞等待，直到活动线程执行`<clinit>()`方法完毕。如果一个类的`<clinit>()`方法中有耗时较长的操作，就可能造成多个进程阻塞，实际中这种阻塞很隐蔽。(其他全县城虽然被阻塞，执行`<clinit>()`方法的线程退出`<clinit>()`方法后，其他线程唤醒后不会再次进入`<clinit>()`方法。同一个类加载器，一个类型只会被初始化一次)。

## 7.4 类加载器

"通过一个类的全限定名来获取描述池类的二进制字节流"这个动作放到JVM外部实现，以便让程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为"类加载器"。

类加载器是Java语言的创新，在类层次划分、OSGI、热部署、代码加密等领域大放异彩。

### 7.4.1 类与类加载器

类加载器用于实现类的加载动作，作用不限于加载阶段。

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在JVM中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗一点：比较两个类是否"相等"，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使两个类来源于同一个class文件，被同一个虚拟机加载，只要他们的类加载器不同，这两个类就不相等。

相等指代表类的Class对象的`equals()`方法、`isAssignableFrom()`方法、`isInstance()`方法的返回结果，也包括instanceof关键字做对象属性关系判定等情况。

### 7.4.2 双亲委派模型

JVM角度看，只存在两种不同的类加载器：

1. 启动类加载器(Bootstrap ClassLoader)，由C++语言实现（只限于HotSpot,像MRP、Maxine等虚拟机，虚拟机本身由Java语言编写，Bootstrap ClassLoader也有Java语言实现。退一步，JRockit和J9都有Bootstrap ClassLoader的Java类存在，但关键方法的实现是使用JNI回调C的实现，这个Bootstrap ClassLoader得实例无法被用户获取到），是虚拟机自身的一部分；
2. 所有其他的类加载器，，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。

Java开发人员角度看，决大部分Java程序都会使用到3种系统提供的类加载器：

1. 启动类加载器(Bootstrap ClassLoader)：这个类加载器负责将存放在`<JAVA_HOME>/lib`目录中的，或者被：-Xbootclasspath参数所指定的路径中，并且是虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户编写自定义启动类的时候，如果需要把加载请求委派给引导类加载器，直接使用null代替即可。
2. 扩展类加载器(Extension ClassLoader)：这个类加载器由`sun.misc.Launcher$ExtClassLoader`实现，负责加载`<JAVA_HOME>/lib`目录中的，或者被java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
3. 应用程序类加载器(Application ClassLoader)：这个类加载器由`sun.misc.Launcher$AppClassLoader`实现，由于这个类加载器是ClassLoader中的`getSystemLoader()`方法的返回值，也成为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

我们程序由着3种类加载器相互配合进行加载的，如有必要，还可以加入自定义的类加载器。

类加载器双亲委派模型：自定义类加载器->应用程序类加载器->扩展类加载器->启动类加载器

类加载器之间的层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承(Inheritance)的关系来实现，而是都是用组合(Composition)关系来复用父加载器的代码。

类加载器的双亲委派模型在JDK1.2期间引入，并不是强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器的实现方式。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求(他的搜索范围里没有找到所需的类)时，子加载器才会尝试自己去加载。

好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。如Object类在程序的各种类加载器中都是同一个类。尝试编写一个与rt.jar已有类同名的Java类，会正常编译但永远不会被执行。
双亲委派模型保证Java程序稳定运行很重要，实现很简单，实现双亲委派模型的代码集中在`java.lang.ClassLoader`的`loadClass()`方法中。先检查是否已经被加载过，若没有加载则调用父加载器的`loadClass()`方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载器加载失败抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。

### 7.4.3 破坏双亲委派模型

双亲委派模型不是强制性约束模型，而是类加载器的实现方式。目前为止，有3次破坏双亲委派模型。

第一次，由于双亲委派模型在JDK1.2中引入，而类加载器和抽象类java.lang.ClassLoader在JDK1.0时代就存在。JDK1.2后的java.lang.ClassLoader添加了一个新的protected方法findClass()，之前是继承java.lang.ClassLoader实现loadClass()方法，JDK1.2后不提倡直接覆盖loadClass()方法，而是把自己的类加载逻辑放到findClass()中。

第二次，双亲委派模型可以解决各个类加载器的基础类同一问题(越基础的类由越上层的加载器进行加载)，如果基础类要调用回用户的代码(JNDI，用启动类加载器去加载，但JNDI目的是对资源进行集中管理和查找，需要调用独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者SPI的代码，启动类加载器不可能认识)，引入线程上下文类加载器(Thread Context ClassLoader).通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程还未设置，则从父类继承一个，如果应用程序全局没有设置过，这个类加载器默认就是应用程序类加载器。

JNDI使用这个线程上下文类加载器加载所需的SPI代码，就是父类加载器请求子类加载器去完成类加载的动作，实际上打通了双亲委派模型的层次结构来逆向使用类加载器，违背了一般性原则，涉及SPI的JNDI、JDBC、JCE、JAXB和JBI等。

第三次，由于用户对程序动态性的追求：代码替换(HotSwap)、模块热部署(Hot Deployment)。

OGSi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要替换Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。

OGSi环境下，类加载器不是双亲委派模型的树状结构，而是更复杂的网状结构，收到类加载请求时，OGSi按如下顺序进行类搜索：

1. 将以java.*开头的类委派给父类加载器加载。
2. 否则，将委派列表名单内的类委派给父类加载器加载
3. 否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。
4. 否则，查找当前Bundle的ClassPath，使用自己的；类加载器加载。
5. 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
6. 否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
7. 否则，类加载失败。

除了开头两点符合双亲委派模型，其余的类查找都是在平级的类加载器中进行的。

