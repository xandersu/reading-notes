# 第六章 类文件结构

## 6.2 无关性基石

各种不同的平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石。

虚拟机的另外一种中立特性——语言无关性。

Clojure、Groovy、JRuby、Jython、Scala

实现语言无关性的基础仍是虚拟机和字节码存储格式。JVM不与语言绑定，只与Class文件这种特定的二进制文件格式所关联，Class文件中包含了JVM指令集和符号表以及若干其他辅助信息。基于安全性考虑，JVM规范要求在Class文件中使用许多强制性的语法和结构化约束，任意一门语言都可以为可以被JVM接受的有效的Class文件。作为一个通用的、机器无关的执行平台，其他语言的实现者都可以将JVM作为语言的产品交付媒介。

## 6.3 Class类文件的结构

任何一个Class文件都对应着唯一一个类或者接口的定义信息，但类和接口并不一定定义在文件里（也可以通过类加载器直接生成）。

Class文件是一组以8位字节为基础单位的二进制流。当需要占用8位字节以上的空间的数据项时，则会按照高位在前（Big-Endian，最高位字节在地址的最低位、最低位字节在地址最高位的顺序）的方式分割成若干个8位字节进行存储。

JVM规范规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，两种数据结构：无符号数和表。

无符号数数据基本数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。

表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。

| 类型           | 名称                | 数量                  |
| -------------- | ------------------- | --------------------- |
| u4             | magic               | 1                     |
| u2             | minor_version       | 1                     |
| u2             | major_version       | 1                     |
| u2             | constant_pool_count | 1                     |
| cp_info        | constant_pool       | constant_pool_count-1 |
| u2             | access_flags        | 1                     |
| u2             | this_class          | 1                     |
| u2             | super_class         | 1                     |
| u2             | interfaces_count    | 1                     |
| u2             | interfaces          | interfaces_count      |
| u2             | fields_count        | 1                     |
| field_info     | fields              | fields_count          |
| u2             | methods_count       | 1                     |
| method_info    | methods             | methods_count         |
| u2             | atrributes_count    | 1                     |
| atrribute_info | atrributes          | atrributes_count      |

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会用一个前置的容量计数器加若干个连续的数据项的形式，称这一系列连续的某一类型的数据为某一类型的集合。

class文件里的数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering，class文件中字节序是Big-Endian）细节，都是被严格限定的，含义长度顺序不允许改变。

### 6.3.1 魔数与Class文件的版本

每个Class文件的头4个字节称为魔数（Magic number），唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件。

Class文件的魔数值为：0xCAFEBABE。

紧接着魔数的4个字节存储的是Class文件的版本号：第5、6个字节是此版本号（minor_version），第7、8个字节是主版本号（major_version）。从45开始每个JDK大版本加1。高版本可以向下兼容，但不能运行之后版本的Class文件，即使文件格式没有任何变化。

JDK1.7主版本号最大值是51。

### 6.3.2 常量池

常量池理解为Class文件中的资源仓库，Class文件结构中与其他项目关联最多的数据结构，也是占用Class文件空间最大的数据项目之一，Class文件中第一个出现表类型的数据结构。

由于常量池中常量的数量是不固定的，所以常量池的入口需要放置一项u2类型的数据，代表常量计数值(constant_pool_count)。从0开始，是特殊考虑，满足后面某些指向常量池的索引值的数据在特定情况下需要表达"不引用任何一个常量池项目"的含义，可以将索引值置为0.只有常量池是从1开始，其它集合类型，接口索引集合、字段表集合、方法表集合的容量计数都从0开始。

常量池主要存放两大类常量：字面量(Literal)和符号引用(Symbolic Reference)。字面量接近于JAva语言层面的常量概念：文本字符串、声明为final的常量值等。符号引用属于编译原理的概念，包含三种常量：

1. 类和接口的全限定名(Fully Qualified Name)。
2. 字段的名称和描述符(Descriptor)
3. 方法的名称和描述符

Java代码在进行Javac编译时，在虚拟机加载Class文件时进行动态链接。Class文件中不会保存各个方法、字段的最终内存布局信息，所以字段、方法的符号引用不经过运行期转换的话无法得到最终的内存布局信息。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。

常量池中每一项常量都是一个表，JDK1.7之前11种，1.7为了更好的支持动态语言的调用新增3种(CONSTANT_MethodHandle_info、CONSTANT_MethodType_info、CONSTANT_InvokeDynamic_info)。

14种表有一个共同特点，表开始第一位是一个u1类型的标志位(tag)，表示那种常量类型。

| 类型                             | 标志 | 描述                     |
| -------------------------------- | ---- | ------------------------ |
| CONSTANT_Utf8_info               | 1    | UTF-8编码的字符串        |
| CONSTANT_Integer_info            | 3    | 整型字面量               |
| CONSTANT_Float_info              | 4    | 浮点型字面量             |
| CONSTANT_Long_info               | 5    | 长整型字面量             |
| CONSTANT_Double_info             | 6    | 双精度浮点型字面量       |
| CONSTANT_Class_info              | 7    | 类和接口的符号引用       |
| CONSTANT_String_info             | 8    | 字符串类型字面量         |
| CONSTANT_Fieldref_info           | 9    | 字段的符号引用           |
| CONSTANT_Methodref_info          | 10   | 类中方法的符号引用       |
| CONSTANT_InterfaceMethodref_info | 11   | 接口中方法的符号引用     |
| CONSTANT_NameAndType_info        | 12   | 字段或方法的部分符号引用 |
| CONSTANT_MethodHandle_info       | 15   | 表示方法句柄             |
| CONSTANT_MethodType_info         | 16   | 标识方法类型             |
| CONSTANT_InvokeDynamic_info      | 18   | 表示一个动态方法调用点   |

CONSTANT_Class_info类型结构：

| 类型 | 名称       | 数量 |
| ---- | ---------- | ---- |
| u1   | tag        | 1    |
| u2   | name_index | 1    |

tag是标志位。name_index是一个索引值，指向常量池中一个CONSTANT_Utf8_info类型常量，代表了这个类(或者借口)的全限定名。

CONSTANT_Utf8_info类型结构：

| 类型 | 名称   | 数量   |
| ---- | ------ | ------ |
| u1   | tag    | 1      |
| u2   | length | 1      |
| u1   | bytes  | length |

length值表示字符串长度是多少字节，紧跟着长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。(缩略编码与普通编码区别：从'\u0001'到'\u007f'之间的字符(1~127的ASCII码)的缩略编码用一个字节表示，从'\u0080'到'\u07ff'之间所有字符缩略编码用两个字节表示，从'\u0800'到'\uffff'缩略编码按普通编码的三个字节表示)。

由于Class文件中方法、字段名都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度就是Java方法、字段名的最大长度，最大长度就是length的最大值，既u2类型能表达的最大值65535。所以超过64KB英文字符的变量或者方法名将无法编译。

常量池所有14种常量项的结构总表(略)

### 6.3.3 访问标志

常量池结束后，紧接着的两个字节代表访问标志(access_flag)，用于识别一些类或者接口层次的访问信息，包括：Class是类还是接口；是否被定义为public类型；是否被定义为abstract类型；类是否为final等。

| 标志名称       | 标志值 | 含义                                                         |
| -------------- | ------ | ------------------------------------------------------------ |
| ACC_PUBLIC     | 0x0001 | 是否为public                                                 |
| ACC_FINAL      | 0x0010 | 是否声明为final，只有类可以设置                              |
| ACC_SUPER      | 0x0020 | 是否允许使用invokespecial字节码指令的新语意，invokespecial指令的语意在JDK1.0.2发生过改变，为了区别使用哪种语意，JDK1.0.2之后编译出来的类的这个标志必须为真。 |
| ACC_INTERFACE  | 0x0200 | 表识是一个接口                                               |
| ACC_ABSTRACT   | 0x0400 | 是否为abstract，接口和抽象类来说标志值为真，其他类标志值为假 |
| ACC_SYNTHETIC  | 0x1000 | 标识这个类并非由用户代码产生                                 |
| ACC_ANNOTATION | 0x2000 | 标识是一个注解                                               |
| ACC_ENUM       | 0x4000 | 标识是一个枚举                                               |

access_flag一共有16个标志位可用，当前只定义了8个(jdk1.5增加了后3个)，没用到的疑虑一律为0。

### 6.3.4 类索引、父类索引和接口索引集合

