
# 16. orderBy是怎么工作的？

1. 内存sort_buffer够的情况下，将数据取出来放到内存中，对排序列做快速排序。
2. 内存sort_buffer不够的情况下，在磁盘上创建临时文件，将数据取出来分到12个文件上，每一份单独排序，在把12份有序的数据合并到一个有序的大文件。
3. 如果排序的单行数据量太大，会将id和排序列取出来，进行快排，然后通过id回表查出来需要的数据。
4. 如果有覆盖索引则无需回表并且索引的值是有序的。



# 18. SQL语句逻辑相同，性能差异大？

1. 不要在where后的索引字段上加函数，会破坏索引的有序性，导致放弃树的搜索能力。
2. 注意隐式的类型转换，=号左边的是字段是varchar，=号右边的是数字。
   1. mysql里字符串和数字比较，会把字符串转换为数字，其实就是在字段上加了cast函数。
3. 一个是 utf8，一个是 utf8mb4，关联查询时会将utf8转换成utf8mb4，也相当于加了个函数。
   1. 优化方式：全转成utf8mb4
   2. SQL等号右边主动转

对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。



# 19 | 为什么我只查一行的语句，也执行这么慢？

1. 表锁，MDL 锁
2. 行锁
3. flush数据
4. 事务太大，undo log很长，老事务从undo log链上找到符合他的可见性的数据要从尾到头进行遍历。



