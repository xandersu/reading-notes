# 第8章 Java多线程与并发

## 进程和线程的区别

### 进程和线程的由来

- **串行：**初期的计算机只能串行执行任务，并且需要长时间等待用户输入
- **批处理：**预先将用户的指令集集中成清单，批量串行处理用户指令，仍然无法并发执行
- **进程：**进程独占内存空间，保存各自的运行状态，相互间不干扰可以相互切换，为并发处理任务提供了可能
  - 进程对应一个程序，一个进程对应一定的内存地址空间，并且只能使用他自己的内存空间，各个进程之间互不干扰，并且进程保存了程序每个时刻的运行状态
  - 为进程切换提供可能
  - 当进程暂停时，会保存当前进程的状态，比如进程的标识、进程使用的资源，在下一次等到io设备完成作业输出结果后再重新切换回来时，便根据之前保存的状态进行恢复然后继续执行，进程让操作系统的并发成为了可能。
  - 虽然并发从宏观上看是由多个任务在执行，但是事实上，对于单核CPU的机器来讲，任何一个具体的时刻，只有一个任务在占用CPU资源。
  - 单核情况下让用户看起来像同一时刻并发执行多个任务的原因是因为CPU分配给单一任务执行的时间片很短，任务切换的频次高，造成所有任务都并发执行的假象
  - 在出现了进程之后，操作系统的性能得到了大幅的提升
  - 虽然进程的出现解决了操作系统的并发问题，但是随着电脑的普及，人们对实时性有了要求。
  - 因为一个进程在一段时间内只做一件事情，如果一个进程有多个任务，他只能逐个的去执行这些子任务，而往往子任务之间不存在顺序上的依赖可以并发执行的。
  - 既然CPU可以按照时间片的方式轮流切换跑进程，让CPU按照更细的时间片执行子任务
- **线程：**共享进程的内存资源，相互间切换更快速，支持更细力度的任务控制，使进程内的子任务得以并发执行。
  - 由于子任务共享内存等资源，因此隶属于同一个进程的子任务间的切换，是不需要切换页目录，这样就为子任务更快地切换提供了可能，所以有了线程
  - 使用线程执行子任务，一个进程就包括了多个子线程，每个线程负责一个子任务。
  - 进程使任务并发称为可能，线程是进程内部的子任务并发称为可能。

### 进程使资源分配的最小单位，线程是CPU调度最小单位

- 所有与进程相关的资源，都被记录在PCB中

  - PCB：描述信息、控制信息、资源信息、CPU现场

- 进程是抢占处理机的调度单位；线程属于某个进程，与线程内其他线程共享线程的资源 

- 线程只由堆栈寄存器、程序计数器和线程控制表(TCB)组成

  - 寄存器用来存储一个线程内的局部变量，但不能存储其他线程的变量
  - 通常一个进程中包含若干个线程，他们可以利用进程拥有的资

  

### 总结

- 线程不能看做独立应用，进程可以看做独立应用
  - 操作系统没有将多个独立的线程看做独立的应用来实现进程的调度和管理以及资源的分配
- 进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径
  - 进程奔溃后不会对其他进程产生影响
  - 线程挂了后，进程也会挂
- 线程没有独立的地址空间，多进程的程序比多线程程序更健壮
- 进程的切换比线程的切换开销大
  - 对于一些要去独立进行并且要共享某些变量的并发操作，只能用线程不能用进程，
  - 每个独立的线程有一个程序运行的入口，顺序执行序列和程序出口，但是线程不能够独立执行，必须依存于某一个应用程序中，由应用程序提供对多个线程的执行控制



## Java进程和线程的关系

- Java对操作系统提供的功能进行封装，包括进程和线程
- 运行一个Java程序会产生一个Java进程，每个Java进程至少包含一个线程
- 每一个Java进程对应一个JVM实例，每一个JVM实例唯一对应一个堆，多个线程共享JVM里的堆，每个线程都有自己私有的栈
- Java采用单线程编程模型，程序会自动创建主线程
- 主线程可以创建子线程，原则上要后于子线程完成执行

一个程序是一个可执行的文件，而一个进程则是一个执行中程序的实例

JVM实例在创建之后，同时会创建很多其他的线程，比如GC是由一个垃圾回收线程执行的

JVM是多线程的



## Thread中的start和run方法的区别

hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/

Thread.start() => JVM_StartThread => thread_entry => Thread.run()

- 调用start()方法会创建一个新的子线程并启动
- run()方法只是Thread的一个普通方法的调用



## Thread和Runnable的关系

Thread是个类实现了Runnable接口

Runnable是个接口，只有一个抽象的run方法，没有创建多线程的能力，真正创建多线程的是Thread.start() 

- Thread是实现了Runnable接口的类，使得run支持多线程
- 因为单一继承原则，推荐多使用Runnable接口



## 如何给run()方法传参

### 实现方法3种

1. 构造函数传参
2. 成员变量传参
3. 回调函数传参



## 如何实现处理线程的返回值

实现方法3种

1. 主线程等待法。让主线程循环等待直到目标子线程返回值为止。
   1. 优点简单。
   2. 缺点：需要自己实现循环等待的逻辑。当需要等待的比较多，代码难写。
   3. 循环多久不确定无法做到精准的控制。
2. 使用Thread类的join阻塞当前线程以等待子线程处理完毕。
   1. 实现简单
   2. 更精准的控制。
   3. 缺点是粒度不够细
3. 通过Callable接口实现：通过FutureTask Or 线程池获取
   1. FutureTask的构造函数接收一个callable接口的实现类。
      1. isDone方法：callable的call方法是否执行完成。
      2. 无参的get方法：阻塞当前调用的线程直到我们的callable的实现类call方法执行完毕为止能取到返回值。能精准的获取到子线程处理后的返回值的。
      3. 带有参数的get方法：timeout超时机制，如果在指定时间内没有获取到callable的call方法后就会抛出异常。
   2. 线程池

















