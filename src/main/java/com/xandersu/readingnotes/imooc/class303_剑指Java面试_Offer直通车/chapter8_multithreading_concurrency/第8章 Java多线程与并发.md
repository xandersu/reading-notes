# 第8章 Java多线程与并发

## 进程和线程的区别

### 进程和线程的由来

- **串行：**初期的计算机只能串行执行任务，并且需要长时间等待用户输入
- **批处理：**预先将用户的指令集集中成清单，批量串行处理用户指令，仍然无法并发执行
- **进程：**进程独占内存空间，保存各自的运行状态，相互间不干扰可以相互切换，为并发处理任务提供了可能
  - 进程对应一个程序，一个进程对应一定的内存地址空间，并且只能使用他自己的内存空间，各个进程之间互不干扰，并且进程保存了程序每个时刻的运行状态
  - 为进程切换提供可能
  - 当进程暂停时，会保存当前进程的状态，比如进程的标识、进程使用的资源，在下一次等到io设备完成作业输出结果后再重新切换回来时，便根据之前保存的状态进行恢复然后继续执行，进程让操作系统的并发成为了可能。
  - 虽然并发从宏观上看是由多个任务在执行，但是事实上，对于单核CPU的机器来讲，任何一个具体的时刻，只有一个任务在占用CPU资源。
  - 单核情况下让用户看起来像同一时刻并发执行多个任务的原因是因为CPU分配给单一任务执行的时间片很短，任务切换的频次高，造成所有任务都并发执行的假象
  - 在出现了进程之后，操作系统的性能得到了大幅的提升
  - 虽然进程的出现解决了操作系统的并发问题，但是随着电脑的普及，人们对实时性有了要求。
  - 因为一个进程在一段时间内只做一件事情，如果一个进程有多个任务，他只能逐个的去执行这些子任务，而往往子任务之间不存在顺序上的依赖可以并发执行的。
  - 既然CPU可以按照时间片的方式轮流切换跑进程，让CPU按照更细的时间片执行子任务
- **线程：**共享进程的内存资源，相互间切换更快速，支持更细力度的任务控制，使进程内的子任务得以并发执行。
  - 由于子任务共享内存等资源，因此隶属于同一个进程的子任务间的切换，是不需要切换页目录，这样就为子任务更快地切换提供了可能，所以有了线程
  - 使用线程执行子任务，一个进程就包括了多个子线程，每个线程负责一个子任务。
  - 进程使任务并发称为可能，线程是进程内部的子任务并发称为可能。

### 进程使资源分配的最小单位，线程是CPU调度最小单位

- 所有与进程相关的资源，都被记录在PCB中

  - PCB：描述信息、控制信息、资源信息、CPU现场

- 进程是抢占处理机的调度单位；线程属于某个进程，与线程内其他线程共享线程的资源 

- 线程只由堆栈寄存器、程序计数器和线程控制表(TCB)组成

  - 寄存器用来存储一个线程内的局部变量，但不能存储其他线程的变量
  - 通常一个进程中包含若干个线程，他们可以利用进程拥有的资

  

### 总结

- 线程不能看做独立应用，进程可以看做独立应用
  - 操作系统没有将多个独立的线程看做独立的应用来实现进程的调度和管理以及资源的分配
- 进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径
  - 进程奔溃后不会对其他进程产生影响
  - 线程挂了后，进程也会挂
- 线程没有独立的地址空间，多进程的程序比多线程程序更健壮
- 进程的切换比线程的切换开销大
  - 对于一些要去独立进行并且要共享某些变量的并发操作，只能用线程不能用进程，
  - 每个独立的线程有一个程序运行的入口，顺序执行序列和程序出口，但是线程不能够独立执行，必须依存于某一个应用程序中，由应用程序提供对多个线程的执行控制



## Java进程和线程的关系

- Java对操作系统提供的功能进行封装，包括进程和线程
- 运行一个Java程序会产生一个Java进程，每个Java进程至少包含一个线程
- 每一个Java进程对应一个JVM实例，每一个JVM实例唯一对应一个堆，多个线程共享JVM里的堆，每个线程都有自己私有的栈
- Java采用单线程编程模型，程序会自动创建主线程
- 主线程可以创建子线程，原则上要后于子线程完成执行

一个程序是一个可执行的文件，而一个进程则是一个执行中程序的实例

JVM实例在创建之后，同时会创建很多其他的线程，比如GC是由一个垃圾回收线程执行的

JVM是多线程的



## Thread中的start和run方法的区别

hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/

Thread.start() => JVM_StartThread => thread_entry => Thread.run()

- 调用start()方法会创建一个新的子线程并启动
- run()方法只是Thread的一个普通方法的调用



## Thread和Runnable的关系

Thread是个类实现了Runnable接口

Runnable是个接口，只有一个抽象的run方法，没有创建多线程的能力，真正创建多线程的是Thread.start() 

- Thread是实现了Runnable接口的类，使得run支持多线程
- 因为单一继承原则，推荐多使用Runnable接口



## 如何给run()方法传参

### 实现方法3种

1. 构造函数传参
2. 成员变量传参
3. 回调函数传参



## 如何实现处理线程的返回值

实现方法3种

1. 主线程等待法。让主线程循环等待直到目标子线程返回值为止。
   1. 优点简单。
   2. 缺点：需要自己实现循环等待的逻辑。当需要等待的比较多，代码难写。
   3. 循环多久不确定无法做到精准的控制。
2. 使用Thread类的join阻塞当前线程以等待子线程处理完毕。
   1. 实现简单
   2. 更精准的控制。
   3. 缺点是粒度不够细
3. 通过Callable接口实现：通过FutureTask Or 线程池获取
   1. FutureTask的构造函数接收一个callable接口的实现类。
      1. isDone方法：callable的call方法是否执行完成。
      2. 无参的get方法：阻塞当前调用的线程直到我们的callable的实现类call方法执行完毕为止能取到返回值。能精准的获取到子线程处理后的返回值的。
      3. 带有参数的get方法：timeout超时机制，如果在指定时间内没有获取到callable的call方法后就会抛出异常。
   2. 线程池



## 线程的状态

#### 六个状态

- 新建(new):线程创建后尚未启动的线程状态。
  - Thread state for a thread which has not yet started.
  - 新创建的线程对象还没有调用start方法。
- 运行(Runnable):包含Running和Ready。
  - 有可能正在执行也有可能正在等待CPU为他分配执行时间。
  - 调用了start方法就处于runnable状态，处于这个状态又分为两个子状态。
    - running：
    - ready：位于可运行线程之中，等待被线程调度选中获取CPU的使用权，在获得CPU时间后就变为running。
- 无限等待（waiting）：不会被分配CPU执行时间，需要显示被唤醒。
  - 没有设置Timeout参数的Object.wait()方法。
  - 没有设置Timeout参数的Thread.join()方法。
  - LockSupport.park()方法。
- 限期等待（Timed Waiting）：在一定时间后会由系统自动唤醒。
  - 不会被分配CPU执行时间，无需等待被其他线程显式唤醒。
  - Thread.sleep()
  - 设置Timeout参数的Object.wait()方法。
  - 设置Timeout参数的Thread.join()方法。
  - LockSupport.parkNanos()方法。
  - LockSupport.parkUtil()方法。
- 阻塞（Blocked）：等待获取排它锁。
  - 阻塞状态和等待状态的区别：阻塞状态在等待着获取到一个排它锁，这个事件将在一个线程放弃这把锁的时候发生。等待状态是在等待一段时间，或者有唤醒动作的时候发生。
  - 在程序等待进入同步区域的时候，线程将进入bloaked的状态。比如：当某个线程进入synchronized关键字修饰的方法或者代码块，即获取锁去执行时，其他想进入此方法或者代码块的线程就只能等着，他们的状态是blocked。
- 结束（Terminated）：已终止线程的状态，线程已结束执行。
  - run方法完成时或者主线程的main方法完成时，我们认为终止了。线程对象也许还活着，但是不是一个单独执行的线程，线程一旦终止了不能复生。
  - 在一个终止的线程上调用start方法会抛出java.lang.IllegalThreadStateException异常。



## Sleep和Wait方法的区别

- sleep是Thread类的方法，wait是Object类的方法
- sleep方法可以在任何地方使用
- wait方法只能在synchronized方法或者synchronized代码块中使用
  - 必须得获取锁才能释放锁。

### 最本质的区别

- Thread.sleep只会让出CPU，不会导致锁行为的改变
- Object.wait不仅让出CPU还会释放已经占用的同步资源锁



## notify和notifyAll的区别

### 两个概念

1. 锁池EntryList
2. 等待池WaitSet

### 锁池EntryList

假设线程A已经拥有了某个对象（不是类）的锁，而其他线程B、C想要调用这个对象的某个synchronized方法（或者块），由于B、C线程在进入对象的synchronized方法（或者块）之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前目前正被线程A所占有，此时B、C线程就会被阻塞，进入一个地方等待锁的释放，这个地方便是该对象的锁池。

### 等待池WaitSet

假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁。



- notifyAll会让所有处于等待此的线程全部进入锁池去竞争获取锁的机会
  - 没有获取到锁而已经待在锁池中的线程只能等待其他机会去获取锁再不能在主动回到等待池中。
- notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会。



## yield

当调用了Thread.yield函数时，会给线程调度器scheduler一个暗示hint，当前线程的愿意让出cpu的使用，但是线程调度器scheduler可能会无视这个暗示hint。

当前线程愿意让出CPU，让其他线程获取cpu使用权，但是取决于线程调度器scheduler，线程调度器scheduler可能会停止当前线程的执行，也可能让当前线程继续执行。



## 如何中断线程

### 已经抛弃的方法

- 通过调用stop()方法停止线程
  - stop方法可以由一个线程去停止另外一个线程，这种方法太过暴力，而且是不安全的。比如说线程A调用线程B的stop方法去停止线程B，调用这个方法时候，线程A其实并不知道线程B执行的具体情况，这种突然间的停止会导致线程B的清理工作无法完成，执行stop方法后线程B会马上释放锁，这有可能会引发数据不同步的问题。
- 通过调用suspend()和resume()方法

### 目前使用的方法

- 调用Interrupt()方法，通知线程该中断了。一种hint。
  - 1、当对一个线程处于被阻塞状态sleep、wait、join等，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。
  - 2、如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续运行，不受影响。
  - **需要被调用的线程配合中断。**
  - 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。
  - 在调用阻塞方法时，正确处理InterruptedException异常，例如catch异常后就结束线程。



## 线程状态以及状态之间的切换

[![J2zj1O.png](https://s1.ax1x.com/2020/04/26/J2zj1O.png)](https://imgchr.com/i/J2zj1O)







