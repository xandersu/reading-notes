# 4-06 持久化方式之RDB_慕课网

# Redis如何做持久化

### RDB（快照）持久化：保存某个时间点的全量数据快照

- 缺点：内存数据的全量同步，数据量大会由于IO而严重影响性能
- 缺点：可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据

```
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes 表示当备份进程出错时，主进程不接受写入操作，如果业务有完善的监控系统，可以关闭。
rdbcompression yes 把rdb文件压缩后保存，建议关闭
```

- save：阻塞redis的服务器进程，直到RDB文件被创建完毕。阻塞主线程
- BGSAVE:FORK出一个子进程来创建RDB文件，不阻塞服务器进程

```
save -> 服务端卡顿
rm -f dump.rdb
ls dump.rdb
./redis-cli
lastsave 返回数字，上次执行save指令的时间
bgsave 客户端不卡顿
lastsave 返回数字，时间变化，上次执行save指令的时间
mv dump.rdb dumpxxxx.rdb 定期保存某个时间点的数据备份
```

# 自动触发RDB持久化方式

- 根据redis.conf配置里save m n 定时触发(用的是bgsave)
- 主从复制，主节点自动触发
- 执行debug reload
- 执行shutdown且没有开启AOF持久化

# BGSAVE原理

1. 检查是否存在AOF/RDB的子进程正在进行，有就返回错误。防止子进程的竞争
2. 触发持久化
3. 调用rdbSaveBackground方法
4. 执行fork
5. 主线程相应其他操作
6. 子进程执行rdb操作

系统调用fork():创建进程，实现了copy-on-write 

# copy-on-write  写时复制

如果有多个调用者同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，知道某个调用者企图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变



当redis需要做持久化时，会调用fork()创建出子进程，父进程继续处理client请求，子进程负责将内存内容写入到临时文件中，由于copy-on-write 机制，父子进程会共享相同的物理页面，当父进程处理写请求时，redis会为父进程要修改的页面创建副本，而不是写共享的页面，所以子进程的数据时执行fork时的整个数据库的快照，当子进程完成临时文件的写入时，用临时文件替换掉原来的快照文件，然后子进程退出。

RDB文件的载入是自动的，如果redis服务器再启动时，如果检测到RDB文件的存在，redis会自动载入这个文件.



### 缺点

- 内存数据全量同步，数据量大会由于I/O而严重影响性能
- 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据