# 4-01 Redis简介

#主流应用架构

客户端

1.请求数据存在于缓存 ⬇️↓
2.直接返回 ⬆️↑
3.miss ⬇️↓
7.熔断 ⬇️↓
8.直接返回 ⬆️↑

缓存层

4.穿透查询 ⬇️↓
5.回种 ⬆️↑

存储层

- **memcache:代码层次类似hash**
    - 支持简单数据类型
    - 不支持数据持久存储
    - 不支持主从
    - 不支持分片
- **Redis**
    - 数据结构丰富
    - 主持数据磁盘持久化存储
    - 支持主从
    - 支持分片(3.0+)
    
# 为什么Redis这么快

100000+ QPS(query per second 每秒内查询次数)

- 完全基于内存，绝大部分请求时纯粹的内存操作，执行效率高。Redis采用单进程单线程的K-V数据库，由C语言编写，数据存储于内存中，读写数据不受硬盘IO限制。

- 数据结构简单，对数据操作也简单。Redis不使用表，不会预 定义或者强制要求用户对redis存储的不同的数据进行关联，性能比关系型数据库高很多，存储结构是键值对类似于hashmap，查找和操作时时间复杂度是O(1)。

- 采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例。面对高并发情况，首先使用单线程来处理，将IO线程与业务线程分开，业务线程使用线程池来避免频繁创建和销毁线程，即便是一次请求阻塞了也不会影响其他请求。

  Redis的单线程结构是主线程是单线程的。  主线程包括IO事件处理，IO对应的相关业务请求的处理；主线程负责过期键处理，复制协调和集群协调等，这些除了IO时间的逻辑会被封装成周期性的任务，由主线程周期性的处理，正因为采用单线程的设计，对于客户端的所有读写请求都有一个主线程串行的处理，因此多个客户端对一个键进行写操作的时候要不会有并发的问题，避免了频繁的上下文切换和锁竞争，效率更高。单线程可以处理高并发的请求，并发不是并行，Redis单线程等配合IO多路复用大幅提高性能。处理网络请求时是单线程，一个Redis server不是单线程的。

- 使用多路I/O复用模型，非阻塞IO。 所有操作都是按照顺序线性执行，但是由于读写操作，等待用户输入、输出是阻塞的，所以IO操作不能直接返回。IO多路复用解决问题。


#多路I/O复用 

FD：file Descriptior，文件描述符

一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射。

传统的阻塞I/O模型

Select系统调用

thread 

selector

channel |channel | channel

Redis采用的I/O多路复用函数：epoll/kqueue/evport/select。

- 因地制宜，根据不同平台使用不同IO多路复用函数，作为子模块提供给上层统一的接口。
- 优先选择时间复杂度O(1)的IO多路复用函数作为底层实现。
- 一时间复杂度为O(n)的select作为保底
- 基于react设计模式监听IO事件。文件事件处理器