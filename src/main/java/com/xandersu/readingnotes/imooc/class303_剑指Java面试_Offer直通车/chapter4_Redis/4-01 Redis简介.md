# 4-01 Redis简介

#主流应用架构

客户端

1.请求数据存在于缓存 ⬇️↓
2.直接返回 ⬆️↑
3.miss ⬇️↓
7.熔断 ⬇️↓
8.直接返回 ⬆️↑

缓存层

4.穿透查询 ⬇️↓
5.回种 ⬆️↑

存储层

- **memcache:代码层次类似hash**
    - 支持简单数据类型
    - 不支持数据持久存储
    - 不支持主从
    - 不支持分片。sharding，将数据库打碎，将大数据分不到多个物理节点的分区方案
- **Redis**
    - 数据结构丰富
    - 主持数据磁盘持久化存储
    - 支持主从
    - 支持分片(3.0+)
    
# 为什么Redis这么快

100000+ QPS(query per second 每秒内查询次数) 10万+

- 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高。Redis采用单进程单线程的K-V数据库，由C语言编写，数据存储于内存中，读写数据不受硬盘IO限制。

- 数据结构简单，对数据操作也简单。Redis不使用表，不会预 定义或者强制要求用户对redis存储的不同的数据进行关联，性能比关系型数据库高很多，存储结构是键值对类似于hashmap，查找和操作时时间复杂度是O(1)。

- 采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例。面对高并发情况，首先使用单线程来处理，将IO线程与业务线程分开，业务线程使用线程池来避免频繁创建和销毁线程，即便是一次请求阻塞了也不会影响其他请求。

  Redis的单线程结构是主线程是单线程的。  主线程包括IO事件处理，IO对应的相关业务请求的处理；主线程负责过期键处理，复制协调和集群协调等，这些除了IO事件的逻辑会被封装成周期性的任务，由主线程周期性的处理，正因为采用单线程的设计，对于客户端的所有读写请求都有一个主线程串行的处理，因此多个客户端对一个键进行写操作的时候要不会有并发的问题，避免了频繁的上下文切换和锁竞争，效率更高。单线程可以处理高并发的请求，并发不是并行，Redis单线程等配合IO多路复用大幅提高性能。处理网络请求时是单线程，一个Redis server不是单线程的。

- 使用多路I/O复用模型，非阻塞IO。 所有操作都是按照顺序线性执行，但是由于读写操作，等待用户输入、输出是阻塞的，所以IO操作不能直接返回。IO多路复用解决问题。

## io密集型和cpu密集型

### IO密集型

- IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。
- 对于io密集型的任务，它的主要时间都在磁盘io上，而io本身在发出中断告知cpu后，cpu只需要短暂的处理一下，之后就由DMA(详见附录)负责数据传输，整个过程对cpu的利用率很低。因此我们需要开更多的线程去充分利用cpu。即一般**线程数 = cpu核心数 \* 2**，如数据库连接池。

### CPU密集型

- CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。
- 对于cpu密集型的任务，它对cpu的利用率很高，所以不需要开更多的线程去提高cpu利用率。假如增加线程，只会引起线程的频繁切换导致本来就不够用的cpu更加不够用。所以一般是**线程数 = cpu核心数 + 1**

1. redis在网络io上使用epoll实现了一个io多路复用的reactor模型，epoll是非阻塞io，所以避免了cpu阻塞在io上，所以它**不是io密集型**，瓶颈不在于等待io导致cpu利用率不高，不需要多个线程来屏蔽等待io执行完成的时间。当然redis的io利用率很高，但是io利用率高并不代表它是io密集型，因为它瓶颈不在等待io上。

2. redis在网络io上使用epoll实现了一个io多路复用的reactor模型使得cpu利用率更高，浪费在io上的时间更少

   redis并不需要多线程来提高cpu利用率减少io等待时间，并且单线程架构也比较容易实现，所以顺理成章就采用了单线程架构。

3. 由于采用了单线程架构，避免了线程线程切换产生的消耗

redis也**不是cpu密集型。**大多数情况下redis机器上的cpu是很够用的。

#### redis的瓶颈在于内存大小和网络带宽。


#多路I/O复用 

### FD：file Descriptior，文件描述符

一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射。用整数表示。

### 传统的阻塞I/O模型

read或者write对文件进行读写时，如果当前FD不可读或者不可写，整个redis服务就不会对其他的服务进行响应。

### 多路I/O复用复用

#### Select系统调用

select方法能够同时监控多个文件描述符的可读、可写情况，当其中的某些文件描述符可读、可写时，select方法就会返回可读以及可写的文件描述符个数。

select方法负责监听文件是否可读或者可写。       

​				thread 

​					  |

​				selector

|                    |                 |

channel |channel | channel

### Redis采用的I/O多路复用函数：epoll/kqueue/evport/select。

- 因地制宜，根据不同平台使用不同IO多路复用函数，作为子模块提供给上层统一的接口。
- 优先选择时间复杂度O(1)的IO多路复用函数作为底层实现。
  - evport，linux的epoll，mac os的kqueue。
  - 这些结构使用了内核内部的结构，并且能够服务几十万的文件描述符，性能比select优秀。
- 以时间复杂度为O(n)的select作为保底
- 基于react设计模式监听IO事件。文件事件处理器使用IO多路复用模块同时监听多个FD，当accept、read、write、close文件事件产生时，文件事件处理器就会回调FD绑定的事件处理器。