# 3-02 优化你的索引

## 二叉查找树上阵

二叉树 复杂度 O(logn)

## B Tree

[![JubF29.png](https://s1.ax1x.com/2020/04/19/JubF29.png)](https://imgchr.com/i/JubF29)

### 定义

- 根节点至少包括两个孩子
- 树中每个节点最多包含有m个孩子(m>=2)  m阶树
- 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子（ceil取上限）
- 所有叶子节点位于同一层
- 假设每个非终端节点中包含有n个关键字信息：
  - Ki(i=1...n)为关键字，且关键字按顺序升序排序 k(i-1) < ki
  - 关键字的个数n必须满足：[ceil(m/2)-1] <= n <= m-1
  - 非叶子节点的指针：P[1],p[2],...,P[M];其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1],K[i])的子树。

比二叉树矮的多，且不会退化成链表。

## B+ Tree

[![JuHvD0.png](https://s1.ax1x.com/2020/04/19/JuHvD0.png)](https://imgchr.com/i/JuHvD0)

B+-Tree是B树的变体，其定义基本与B树相同，除了：

- 非叶子节点的子树指针与关键字个数相同
- 非叶子节点的子树指针p[i]指向关键字值(K[i],K[i+1])的子树
- 非叶子节点仅用做索引，数据都保存在叶子节点中
- 所有叶子节点均有一个链指针指向下一个叶子节点，并按大小顺序链接。（支持范围统计。）

###B+树更适合用作存储索引

- B+树的磁盘读写代价更低。内部结构没有指向关键字具体信息的指针，不存放数据只存放索引信息，内部节点比B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，这个盘块所能容纳的关键字数量更多，一次性读入内存中的关键字也就越多，IO读写次数相对较低。
- B+树的查询效率更稳定。因为内部节点不是最终指向文件内容的节点，而是叶子节点的关键字索引，所以任何关键字查找必须走一条从根节点到叶子节点的完整的路，所有关键字查询的长度相同，导致每个数据的查询效率几乎相同稳定的O(logn)。
- B+树更有利于对数据库的扫描。范围查询有更高的性能。

## Hash索引

根据哈希函数的运算，只需一次定位就能找到数据。

### 缺点：

- 仅仅能满足 "=" ，"IN" 不能使用范围查询。只能用于等值过滤不能用于范围查询。哈希算法处理后的哈希值大小关系不能保证和hash运算前完全一样。
- 无法被用来避免数据的排序操作。hash索引存放的是hash预算后的值，无法利用索引值进行排序运算。
- 不能利用部分索引键查询。
- 不能避免表扫描
- 遇到大量Hash值相等的情况后性能并不一定比B+树索引高

## BitMap索引

### 位图索引

表的某个字段只有几种值的时候（性别）

oracle支持

不是主流索引

用来统计非常快

### 缺点

- 锁的粒度非常大

- 不适合高并发

- 用于统计

