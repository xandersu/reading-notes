# 第9章 Java多线程与并发-原理

# Synchronized

#### 线程安全的主要诱因

- 存在共享数据（也称为临界资源）
- 存在多条线程共同操作这些共享数据

#### 解决问题的根本方法：

同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作。



## 互斥锁

#### 特性

1. 互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块（复合操作）进行访问。互斥性也被称为操作的原子性。
2. 可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。

**synchronized锁的不是代码，锁的都是对象**



### 根据获取的锁的分类：获取对象锁和获取类锁

#### 获取对象锁的两种用法：

1. 同步代码块(synchronized(this)、synchronized(类实例对象))，锁的是小括号()中的实例对象。
2. 同步非静态方法（synchronized method），锁的是当前对象的实例对象。

#### 获取类锁的两种用法：

1. 同步代码块synchronized(类.class)，锁的是小括号()中的类对象（class对象）。
2. 同步非静态方法（synchronized method），锁的是当前对象的实例对象（class对象）。



### 对象锁和类锁的总结：

1. 有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块。
2. 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块的线程会被阻塞。
3. 若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象的同步方法的线程会被阻塞。
4. 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步方法的线程会被阻塞，反之亦然。
5. 同一个类的不同对象的对象锁互不干扰。
6. 类锁由于也是一种特殊的对象锁，因此表现和上述1，2，3，4一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的。
7. 类锁和对象锁互不干扰。



# synchronized底层实现原理

### 实现synchronized的基础

- Java对象头
- Monitor



### 对象在内存中的布局

- 对象头
- 实例数据
- 对齐填充



### 对象头的结构

| 虚拟机位数 |       头对象结构       |                             说明                             |
| :--------: | :--------------------: | :----------------------------------------------------------: |
|  32/64位   |       Mark Word        |   默认存储对象的hashCode，分代年龄，锁类型，锁标志位等信息   |
|  32/64位   | Class Metadata Address | 类型指针指向元素对象的类元数据，JVM通过这个指针确定该对象是哪个类的数据 |



### Mark Word

由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此，考虑到JVM的空间效率，Mark Word被设计成为一个非固定的数据结构，以便存储更多有效的数据。根据对象本身的状态复用自己的存储空间。



锁状态  25bit     4 bit    1bit    2bit

​            23bit  2bit         是否是偏向锁   锁标志位

无状态锁   对象hashCode、对象分代年龄     01

轻量级锁   指向锁记录的指针                         00

重量级锁    指向重量级锁的指针                10

GC标志       空，不需要记录信息                   11

偏向锁  线程id  Epoch  对象分代年龄   1    01



### Monitor：每个Java对象天生自带了一把看不见的锁

管程、监视器锁   理解成一个同步工具，描述为一种同步机制， 通常描述为一个对象

 Monitor是由ObjectMonitor实现的。位于hotspot源码内，C++实现。

ObjectMonitor{

owner ：指向持有ObjectMonitor对象的线程

entryList：

waitSet：

count： 计数器

}

Monitor对象存在于每个Java对象的对象头当中

entryList     owner     waitSet

enter ， acquire  ，  release ， acquire ，  release and exit



### 什么是重入

从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，是允许的，这种情况属于重入。



为了保证在方法异常完成时，monitorenter和monitorexit依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有异常，目的是用来执行monitorexit指令。



#### synchronized问题

- Java早期版本中，synchronized属于重量级锁，底层依赖于Mutex Lock实现。
- 线程之间的切换需要从用户态切换到核心态，开销较大。

#### synchronized优化

- 自适应自旋
- 锁消除
- 锁粗化
- 轻量级锁
- 偏向锁



## 自旋锁和自适应自旋锁

### 自旋锁

- 很多情况下，共享数据的锁定状态持续时间较短，，为了这段时间挂起和恢复阻塞线程、切换线程不值得
  - 在多处理器的环境下，可以让另外没有获取到锁的线程等待一会但不放弃CPU执行时间
  - 等待一会但不放弃CPU执行时间就是**自旋**
- 通过让线程执行忙循环等待锁的释放，不让出CPU
  - while(true)
  - 不像Sleep一样放弃CPU执行时间
  - JDK4引入默认关闭，JDK6默认开启，
- 如果占用时间短效果很好
- 缺点：如果锁被其他线程长时间占用，会带来很多性能上的开销
  - 线程自旋时，始终占用CPU的时间片
  - preBlockSpin参数更改自旋后锁升级的次数

### 自适应自旋锁

JDK6引入

- 自旋的次数不确定
- 由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定
  - 如果在同一个锁对象上，自选等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的概率很大，会自动增加等待时间。相反，如果对于某个锁自旋很少成功获取到锁，那在以后要获取锁时，将可能省略掉自旋过程，以避免浪费处理器资源。

### 锁消除

更彻底的优化

- JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁



### 锁粗化

另一个极端

- 扩大加锁范围，避免反复加锁解锁



## synchronized的四种状态

- 无锁、偏向锁、轻量级锁、重量级锁
- 锁膨胀方向：无锁 => 偏向锁 => 轻量级锁 => 重量级锁



## 偏向锁

- 大多数情况下，锁不存在多线程竞争，总是由同一个线程多次获得

#### 核心思想：

如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark word 的结构也变为偏向锁结构，当该线程再次请求锁，无需在做同步操作，即获取锁的过程只需要检查Mark word 的锁标记位为偏向锁以及当前线程ID等于Mark word 的Thread ID即可，这样就省去了大量有关锁申请的操作。

不适合用于锁竞争比较激烈的多线程场合



## 轻量级锁

轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。

适应场景：线程交替执行同步块

若存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。

### 轻量级锁的加锁过程

1. 在代 码即将进入同步块的时候，如果此同步对象没有被锁定(锁标志位为“ 01”状态)，虚拟机 首先将在当前线程的钱帧中建立 一个名为锁记录( Lock Record)的空 间 ，用于存储锁对象 目前的 Mark Word 的拷贝 (官方为这份拷贝 加了一个 Displaced 前缀，即 Displaced Mark Word)，这时候线程堆楼与对象头的状态如图 13-3 所示 。
2. 拷贝对象头中的 Mark Word 复制到锁记录中。
3. 然后，虚拟机将使用 CAS 操作尝试把对象的 Mark Word 更新为指向 Lock Record 的指针。并将Lock Record里的owner指针指向object mark word。
4. 如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象 Mark W ord 的锁标志位( Mark Word 的最后两个比特)将转变为“00”，表示此对象处于轻量级锁定状 态 。
5. 如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象 的锁 。 虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个 锁对象已经被其他线程抢占了 。 如果出现两条以上的 I 线程争用同一个锁的情况，那轻量级锁就不再有效，! 必须要膨胀为重 量 级锁，锁标志的状态值变为“ l。”， 此时 Mark Word 中存储的就是指向重 量级 锁(互斥 量) 的指针，后面等待锁的线程也必须进入阻 塞状态 。

### 轻量级锁的解锁过程

1. 通过 CAS 操作来进行的，如果对象的 Mark Word仍然指向线程的锁记录，那就用 CAS操作把对图 13-4 象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来 。 
2. 假如能够成功替换，那整个同步过程就顺利完成了;
3. 如果替换失败，则说 明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。



### 锁的内存语义

当线程释放锁时，Java内存模型会把该线程对应的本地内存中的共享变量刷新到主存中。

而当线程获取锁时，Java内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。



### 偏向锁、轻量级锁、重量级锁的汇总

| 锁       | 优点                                                         | 缺点                                                         | 使用场景                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------ |
| 偏向锁   | 加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗               | 只有一个线程访问同步块或者同步方法的场景         |
| 轻量级锁 | 竞争的线程不会阻塞，提高了响应速度                           | 若线程长时间抢不到锁，自旋会消耗CPU性能                      | 线程交替执行同步块或者同步方法的场景             |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢，再多线程下，频繁的获取释放锁，会带来巨大的性能消耗 | 追求吞吐量，同步块或者同步方法执行时间较长的场景 |

















