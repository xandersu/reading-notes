# 第6章 编码技巧

- 递归控制
- 循环控制
- 边界控制
- 数据结构



### 在白板上写程序

- 程序写在：白板、纸币，WOrd文档、记事本
- 修改不变、缩进不变、对齐困难
- 心里不抵触、先思考后写、不要惧怕修改/重写



## 数学归纳法

**用来证明断言对所有自然数成立**

- 证明对于N=1成立
- 证明N>1时：如果对于N-1成立，那么对于N成立



### 求证：1+2+3+4+5+...+n = (1+n)n/2

- 1 = 1*2/2
- 如果1+2+3+...+(n-1) = (n-1)n/2
- 那么 1+2+3+... + n = (1+2+3+...+(n-1)) + n = (n-1)n/2 +n = (n(n-1)+2n)/2 = n(n+1)/2

### 换成程序语言

`int sum(int n){`

`if(n==1)return 1;`

`return sum(n-1)+n;`

`}`

### 数学归纳法的正确性

**公理**



## 递归控制

#### 如何证明递归函数正确执行

- 数学归纳法中的数学/自然语言 <--> 程序语言

#### 递归书写方法

- 严格定义递归函数作用，包括参数、返回值、Side-effect
- 先 **一般** ，后 **特殊**
- 每次调用 **必须** 缩小问题规模
- 每次问题规模缩小程度必须为 **1**



### 为何面试喜欢问链表（单向）

- 容易理解
- 代码难写



- 多个参数的初始值
- Side-effect的维护



## 递归的缺点

### Stack

- 函数调用开销
- 栈溢出
- 问题规模：million 栈大小



## 循环控制

### 不要尝试递归-> 非递归

- 一般化方法依然需要使用栈
- 代码复杂
- 不能根本解决问题

### 循环不变式（loop invariant）

#### 断言定义各变量所满足的条件

var a,b;

while(...){

​	...

}

### 循环书写方法

- 定义循环方法，并在循环体每次结束后 **保持** 循环不变式。
- 先 **一般** ，后 **特殊**
- 每次 **必须** 向前推进循环不变式中涉及的变量值
- 每次推进的规模必须为 **1**



### 循环解决链表翻转

newHead 指向翻转成功的链表

currentHead 指向还没有翻转的链表



### 链表DeleteIf



## 边界控制

### 二分查找

- 有序数组中查找元素K，返回K所在下标
- binartSearch([1,2,10,15,100],5) == 3



### 二分查找思路

- 规定要查找的值K可能在的数组arr内下标区间a，b
- 计算区间a，b的中间点m
- 若k<arr[m]，将区间缩小为a,m，继续二分查找
- 若k>arr[m]，将区间缩小为m,b，继续二分查找
- 若k=arr[m]，找到元素位置m



## 数据结构

- 数组。开辟的连续内存空间；根据下标随机访问；插入和删除比较耗时；
- 链表。无法随机访问，比较耗时；插入和删除元素非常方便；
- 队列（先进先出）、栈（先进后出）。不支持随机访问。只能push和pop。



### 树

- 二叉树。
- 搜索树。
- 堆/优先队列。push和pop；



### 栈、队列、优先队列

push(1);

push(3);

push(2);

pop();

pop();

pop();

- 栈：2、3、1
- 队列：1、3、2
- 优先队列：1、2、3



### Map<K,V> / Set<K>

- HashMap / HashSet -> k.hashCode();
- TreeMap / TreeSet -> k implements Comparable



### 图

- 无向图
- 有向图
- 有向无环图

#### 图的算法

- 深度优先遍历
- 广度优先遍历
- 拓扑排序
- 最短路径 / 最小生成树



## 树

- 易于理解
- 难度大，综合性强



### 二叉树遍历

- 前序遍历
  - 先遍历树根
  - 前序遍历左子树
  - 前序遍历右子树
- 中序遍历
  - 中序遍历左子树
  - 遍历树根
  - 序遍历右子树
- 后序遍历
  - 后序遍历左子树
  - 后序遍历右子树
  - 后序遍历树根
- 层次遍历



### 前序遍历

- 先遍历树根
- 前序遍历左子树
- 前序遍历右子树



## 根据前序中序构造二叉树

前序：ABDEGCF

中序：DBGEACF

求后序遍历

### 总结

- 思考算法：只想着把规模缩小就好
- 初始值的确定：根据递归函数定义



## 寻找中序遍历时的下一个节点 











