# HashMap

hashmap对hash算法如何优化的

h= (key.hashCode())^(h>>>16);

^异或 不一样是1 一样是0

让高低16位都可以参加运算

寻址算法的优化
(n-1) & hash 到数组的一个位置

取模运算性能没有位运算高

(n-1) & hash 和 hash 对 n 取模结果是一样的，只要数组的长度n一直是2的n次方

扰动函数的优化，让高16位可以参与运算
寻址算法的优化，只要数组的长度n一是2的n次方，和取模结果一样并且性能更高


## HashMap解决hash冲突
链表+红黑树

如果链表长度大于8转换成红黑树
小于6转回链表

红黑树的查询时间复杂度是O(logn)

## 如何扩容

扩容后需要rehash

判断二进制结果中是否多出来一个bit的1，如果没多就是原来的index，
如果多了就是index+oldCap，避免在扩容时对每个元素rehash，对每个hash做数组.length取模

// loHead 表示老值,老值的意思是扩容后，该链表中计算出索引位置不变的元素
// hiHead 表示新值，新值的意思是扩容后，计算出索引位置发生变化的元素
// 举个例子，数组大小是 8 ，在数组索引位置是 1 的地方挂着两个值，两个值的 hashcode 是9和33。
// 当数组发生扩容时，新数组的大小是 16，此时 hashcode 是 33 的值计算出来的数组索引位置仍然是 1，我们称为老值
// hashcode 是 9 的值计算出来的数组索引位置是 9，就发生了变化，我们称为新值。

// java 7 是在 while 循环里面，单个计算好数组索引位置后，单个的插入数组中，在多线程情况下，会有成环问题
// java 8 是等链表整个 while 循环结束后，才给数组赋值，所以多线程情况下，也不会成环

